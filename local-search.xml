<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ 离港篇</title>
    <link href="/2021/04/17/cpp-1/"/>
    <url>/2021/04/17/cpp-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><h2 id="引用是什么？"><a href="#引用是什么？" class="headerlink" title="引用是什么？"></a>引用是什么？</h2><p>引用是变量的别名</p><h2 id="基本数据类型引用"><a href="#基本数据类型引用" class="headerlink" title="基本数据类型引用"></a>基本数据类型引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> &amp;b = a; <span class="hljs-comment">//引用必须初始化</span><br></code></pre></td></tr></table></figure><h2 id="结构体类型的引用"><a href="#结构体类型的引用" class="headerlink" title="结构体类型的引用"></a>结构体类型的引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//定义一个结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br>&#125;Coor;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> namespaces <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Coor c1;<br>Coor &amp;c = c1;  <span class="hljs-comment">//结构体类型引用</span><br>c.x = <span class="hljs-number">10</span>;<br>c.y = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; c1.x &lt;&lt; c1.y;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指针类型的引用"><a href="#指针类型的引用" class="headerlink" title="指针类型的引用"></a>指针类型的引用</h2><p>格式：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">类型 *<span class="hljs-meta">&amp;指针引用名 = 指针；</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> namespaces <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> *p = &amp;a;<br><span class="hljs-keyword">int</span> *&amp;q = p; <span class="hljs-comment">//指针类型的引用</span><br>*q = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用作函数参数"><a href="#引用作函数参数" class="headerlink" title="引用作函数参数"></a>引用作函数参数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//实现一个交换值的函数</span><br><br><span class="hljs-comment">//没有引用时单纯用指针传参数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br>c = *a;<br>*a = *b;<br>*b = c;<br>&#125;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>, y = <span class="hljs-number">20</span>;<br>fun(&amp;x, &amp;y);<br><br><br><span class="hljs-comment">//引用作函数参数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span>  <span class="hljs-comment">//引用作为参数，起了别名a, b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br>    c = a;<br>    a = b;<br>    b = c;<br>&#125;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>, y = <span class="hljs-number">20</span>;<br>fun(x, y); <span class="hljs-comment">// 相当于给x取别名a，给y取别名b</span><br></code></pre></td></tr></table></figure><h2 id="C-语言引用代码演示"><a href="#C-语言引用代码演示" class="headerlink" title="C++ 语言引用代码演示"></a>C++ 语言引用代码演示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">using</span> namespaces <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;Coord;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//基本数据类型的引用</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-meta"># int &amp;b = NULL; <span class="hljs-comment">//如果这样写会报错，只有别名无法成立，引用不能单独存在，引用必须初始化</span></span><br>    <span class="hljs-keyword">int</span> &amp;b = a;<br>    <br>    b = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出20</span><br>    <br>    a = <span class="hljs-number">30</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出30</span><br>    <br>    <span class="hljs-comment">// 结构体类型的引用</span><br>    Coord c;<br>    Coord &amp;c1 = c;<br>    c1.x = <span class="hljs-number">10</span>;<br>    c1.y = <span class="hljs-number">20</span>;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; c.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; c.y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-comment">// 指针类型的引用</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> *p = a;<br>    <span class="hljs-keyword">int</span> *&amp;q = p;<br>    <br>    *q = <span class="hljs-number">5</span>; <span class="hljs-comment">//通过*q访问a</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-comment">// 引用作函数的参数</span><br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    fun(x, y);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br>    c = a;<br>    a = b;<br>    b = c;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-语言-const-关键字"><a href="#C-语言-const-关键字" class="headerlink" title="C++ 语言 const 关键字"></a>C++ 语言 const 关键字</h1><p>控制变化的 const</p><h2 id="const-与基本数据类型"><a href="#const-与基本数据类型" class="headerlink" title="const 与基本数据类型"></a>const 与基本数据类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>变量名</th><th>存储地址</th><th>存储内容</th></tr></thead><tbody><tr><td>x</td><td>&amp;x</td><td>3 (变量)</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>; <span class="hljs-comment">//常量</span><br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>变量名</th><th>存储地址</th><th>存储内容</th></tr></thead><tbody><tr><td>x</td><td>&amp;x</td><td>3 (常量)</td></tr></tbody></table></div><h2 id="const-与指针类型"><a href="#const-与指针类型" class="headerlink" title="const 与指针类型"></a>const 与指针类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>*p = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-number">2.</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> *p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 1和2代码完全等价</span><br><br><span class="hljs-comment">//但是 int * const p = NULL; 表示其他含义</span><br><br><span class="hljs-comment">// const 可以一处加， 也可以两处加const</span><br><span class="hljs-number">3.</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-number">4.</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> p = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 3和4代码完全等价</span><br><br></code></pre></td></tr></table></figure><p>下面来看一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;x;<br><span class="hljs-comment">//p = &amp;y; 正确//*P = 4; 错误</span><br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>变量名</th><th>存储地址</th><th>存储内容</th></tr></thead><tbody><tr><td>x</td><td>&amp;x</td><td>3</td></tr><tr><td>p</td><td>&amp;p</td><td>&amp;x</td></tr></tbody></table></div><p>另一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>; <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p = &amp;x; <span class="hljs-comment">//p=&amp;y;将会是错误的</span><br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>变量名</th><th>存储地址</th><th>存储内容</th></tr></thead><tbody><tr><td>x</td><td>&amp;x</td><td>3</td></tr><tr><td>p</td><td>&amp;p</td><td>&amp;x (常量)</td></tr></tbody></table></div><p>再一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p = &amp;x;<br><span class="hljs-comment">// p = &amp;y; *p = 4; 都是错误的</span><br><br><span class="hljs-comment">// const int *const p = &amp;x; 两个const， 则不能够通过p修改常量的值</span><br></code></pre></td></tr></table></figure><h2 id="const-与引用"><a href="#const-与引用" class="headerlink" title="const 与引用"></a>const 与引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;y = x;<br><span class="hljs-comment">// x = 10; 正确// y = 20; 错误</span><br><br><span class="hljs-comment">// y 作为 x 的别名，在前面加了个const ， 则不允许通过y修改x的值， 但可以通过变量名x本身修改</span><br></code></pre></td></tr></table></figure><h2 id="const-使用错误示例"><a href="#const-使用错误示例" class="headerlink" title="const 使用错误示例"></a>const 使用错误示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>;x = <span class="hljs-number">5</span>;<br><br><span class="hljs-number">2.</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> y = x;y = <span class="hljs-number">5</span>;<br><br><span class="hljs-number">3.</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *y = &amp;x;*y = <span class="hljs-number">5</span>;<br><br></code></pre></td></tr></table></figure><h2 id="错误题目"><a href="#错误题目" class="headerlink" title="错误题目"></a>错误题目</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">判断： <span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>;<span class="hljs-keyword">int</span> *p = &amp;a;<br>这是错的<br>原因：<br>变量的权限比常量<span class="hljs-keyword">const</span>的权限要高，而计算机允许权限高的变量赋值给权限低的常量<br></code></pre></td></tr></table></figure><h2 id="const-的小总结"><a href="#const-的小总结" class="headerlink" title="const 的小总结"></a>const 的小总结</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">（<span class="hljs-number">1</span>）常量的地址不能赋值给指针<br>（<span class="hljs-number">2</span>）<span class="hljs-keyword">const</span> 放在<span class="hljs-keyword">int</span> 前或者放在<span class="hljs-keyword">int</span> 后都是等价的，但是放在 * 号前和 * 号后是不同的，要加以区分。<br>（<span class="hljs-number">3</span>）指针指向<span class="hljs-keyword">const</span>修饰的变量时 ， 应该是<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> *p = &amp;a ;  (被引用者的权限应该大于或等于引用者) <br>（<span class="hljs-number">4</span>）常引用作为函数的参数，<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;b)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="C-函数新特性"><a href="#C-函数新特性" class="headerlink" title="C++ 函数新特性"></a>C++ 函数新特性</h1><h2 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j=<span class="hljs-number">5</span>, <span class="hljs-keyword">int</span> k=<span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 参数j和k有了默认值</span></span><br></code></pre></td></tr></table></figure><p>但是，下面的写法是错误的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j=<span class="hljs-number">5</span>, <span class="hljs-keyword">int</span> k)</span><span class="hljs-comment">//这是错误的</span></span><br></code></pre></td></tr></table></figure><p><strong>有默认参数值的参数必须在参数表的最右端</strong></p><p><strong>函数在声明时可以写参数默认值，但是在定义时不要写默认值</strong></p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j=<span class="hljs-number">5</span>, <span class="hljs-keyword">int</span> k=<span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fun(<span class="hljs-number">20</span>);<span class="hljs-comment">//相当于fun(20, 5, 10);</span><br>    fun(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<span class="hljs-comment">//相当于fun(20, 30, 10);</span><br>    fun(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>);<span class="hljs-comment">//相当于fun(20, 30, 40);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; j &lt;&lt; k &lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>无实参则用默认值，否则实参覆盖默认值</strong></p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="什么是函数重载？"><a href="#什么是函数重载？" class="headerlink" title="什么是函数重载？"></a>什么是函数重载？</h3><p>在相同作用域内， 用<strong>同一函数名</strong>定义的多个函数，  <strong>参数个数</strong>和<strong>参数类型</strong>不同</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//to do</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//to do</span><br>&#125;<br></code></pre></td></tr></table></figure><p>思考：编译器如何识别重载的函数？</p><p>第一个函数相当于<strong>getMax_int_int_int</strong></p><p>第二个函数相当于<strong>getMax_double_double</strong></p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>内联函数与普通函数的区别：</p><p><img src="D:\blog\20to30\source\pictures\屏幕截图 2021-04-16 235522.png" alt=""></p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>内联函数关键字：inline</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>, j = <span class="hljs-number">20</span>, k = <span class="hljs-number">30</span>, m;<br>    m = max(i, j ,k);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;max=&quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>讲上面的代码展开之后， 就可以得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>, j = <span class="hljs-number">20</span>, k = <span class="hljs-number">30</span>, m;<br>    <span class="hljs-keyword">int</span> a, b, c;<br>    a = i; b = j; c = k;<br>    <span class="hljs-keyword">if</span>(b &gt; a)a = b;<br>    <span class="hljs-keyword">if</span>(c &gt; a)a = c;<br>    m = a;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;max=&quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>思考：为什么不所有函数都使用内联方式呢？</p><ol><li>内联编译时建议性的，由编译器决定。</li><li>逻辑简单而且调用频繁的函数建议使用内联。</li><li>递归函数无法使用内联方式。</li></ol><h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++  内存管理"></a>C++  内存管理</h1><p>内存的本质是什么？    资源</p><p>谁掌管内存资源？    操作系统</p><p>我们能做什么？    申请/归还</p><h2 id="内存的申请和释放"><a href="#内存的申请和释放" class="headerlink" title="内存的申请和释放"></a>内存的申请和释放</h2><p><strong>申请/归还内存资源就是内存管理</strong></p><p>申请内存    <strong>new</strong></p><p>释放内存    <strong>delete</strong></p><p><strong>new</strong> 和 <strong>delete</strong> 都是运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//申请内存</span><br><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><br><span class="hljs-comment">//释放内存</span><br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p>思考：如何申请和释放<strong>块内存</strong>呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">// 申请块内存</span><br><br><span class="hljs-keyword">delete</span> []arr;<span class="hljs-comment">// 释放块内存</span><br></code></pre></td></tr></table></figure><h2 id="内存管理其他方式"><a href="#内存管理其他方式" class="headerlink" title="内存管理其他方式"></a>内存管理其他方式</h2><p><img src="D:\blog\20to30\source\pictures\屏幕截图 2021-04-17 093448.png" alt=""></p><h2 id="申请内存不一定成功"><a href="#申请内存不一定成功" class="headerlink" title="申请内存不一定成功"></a>申请内存不一定成功</h2><p>不一定成功，所以程序中要有<strong>判断是否为空指针</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1000</span>];<br><br><span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == p)<br>&#123;<br><span class="hljs-comment">//内存分配失败</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="释放内存注意事项"><a href="#释放内存注意事项" class="headerlink" title="释放内存注意事项"></a>释放内存注意事项</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//普通内存示例</span><br><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == p )<br>&#123;<br>    <span class="hljs-comment">//内存分配失败</span><br>    <span class="hljs-comment">//异常处理</span><br>&#125;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br><br><br><span class="hljs-comment">//块内存示例</span><br><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1000</span>];<br><span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == p )<br>&#123;<br>    <span class="hljs-comment">//内存分配失败</span><br>    <span class="hljs-comment">//异常处理</span><br>&#125;<br><span class="hljs-keyword">delete</span> []p;<br>p = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ol><li>使用new申请内存， 使用delete释放内存。</li><li>申请内存需要判断是否成功， 释放内存需要设空指针。</li><li>new与delete配套使用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【手写数字识别】之数据处理</title>
    <link href="/2021/01/29/paddle-2-2/"/>
    <url>/2021/01/29/paddle-2-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【手写数字识别】之数据处理"><a href="#【手写数字识别】之数据处理" class="headerlink" title="【手写数字识别】之数据处理"></a>【手写数字识别】之数据处理</h1><p>上一节，我们通过调用飞桨提供的API（<a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api_cn/data_cn/dataset_cn/mnist_cn.html">paddle.dataset.mnist</a>）加载MNIST数据集。但在工业实践中，我们面临的任务和数据环境千差万别，通常需要自己编写适合当前任务的数据处理程序，一般涉及如下五个环节：</p><ul><li>读入数据</li><li>划分数据集</li><li>生成批次数据</li><li>训练样本集乱序</li><li>校验数据有效性</li></ul><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>在读取数据与处理前，首先要加载飞桨和数据处理库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载飞桨和相关数据处理的库</span><br><span class="hljs-keyword">import</span> paddle<br><span class="hljs-keyword">import</span> paddle.fluid <span class="hljs-keyword">as</span> fluid<br><span class="hljs-keyword">from</span> paddle.fluid.dygraph.nn <span class="hljs-keyword">import</span> Linear<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> gzip<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> random<br></code></pre></td></tr></table></figure><h2 id="读入数据并划分数据集"><a href="#读入数据并划分数据集" class="headerlink" title="读入数据并划分数据集"></a>读入数据并划分数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 声明数据集文件位置</span><br>datafile = <span class="hljs-string">&#x27;./work/mnist.json.gz&#x27;</span><br>print(<span class="hljs-string">&#x27;loading mnist dataset from &#123;&#125; ......&#x27;</span>.<span class="hljs-built_in">format</span>(datafile))<br><span class="hljs-comment"># 加载json文件</span><br>data = json.load(gzip.<span class="hljs-built_in">open</span>(datafile))<br>print(<span class="hljs-string">&#x27;mnist dataset load done&#x27;</span>)<br><span class="hljs-comment"># 读取到的数据区分数据集，验证集，测试集</span><br>train_set, val_set, eval_set = data<br><br><span class="hljs-comment"># 数据集相关参数，图片高度 IMG_ROWS, 图片宽度 IMG_COLS</span><br>IMG_ROWS = <span class="hljs-number">28</span><br>IMG_COLS = <span class="hljs-number">28</span><br><br><span class="hljs-comment"># 打印数据信息</span><br>imgs, labels = train_set[<span class="hljs-number">0</span>], train_set[<span class="hljs-number">1</span>]<br>print(<span class="hljs-string">&quot;训练数据集数量：&quot;</span>, <span class="hljs-built_in">len</span>(imgs))<br><br><span class="hljs-comment"># 观察验证集数量</span><br>imgs, labels = val_set[<span class="hljs-number">0</span>], val_set[<span class="hljs-number">1</span>]<br>print(<span class="hljs-string">&quot;验证数据集数量：&quot;</span>, <span class="hljs-built_in">len</span>(imgs))<br><br><span class="hljs-comment"># 观察测试集数量</span><br>imgs, lables = <span class="hljs-built_in">eval</span>[<span class="hljs-number">0</span>], <span class="hljs-built_in">eval</span>[<span class="hljs-number">1</span>]<br>print(<span class="hljs-string">&quot;测试数据集数量：&quot;</span>, <span class="hljs-built_in">len</span>(imgs))<br></code></pre></td></tr></table></figure><p><strong>当几个模型的准确率在测试集上差距不大时，尽量选择网络结构相对简单的模型。往往越精巧设计的模型和方法，越不容易在不同的数据集之间迁移。</strong></p><h2 id="训练样本乱序、生成批次数据"><a href="#训练样本乱序、生成批次数据" class="headerlink" title="训练样本乱序、生成批次数据"></a>训练样本乱序、生成批次数据</h2><ul><li><p>训练样本乱序：先将样本按顺序进行编号，建立ID集合 index_list 。然后将 index_list 乱序，最后按乱序后的顺序读取数据。</p><p><strong>说明</strong>：通过大量实验发现，模型对最后出现的数据印象更加深刻。<strong>训练数据导入后，越接近模型训练结束，最后几个批次数据对模型参数的影响越大</strong>。为了避免模型记忆影响训练效果，需要进行样本乱序操作。</p></li><li><p>生成批次数据：先设置合理的 batch_size , 再将数据转变为符合模型输入要求的 np.arrray 格式返回。同时，在返回数据时将 Python 生成器设置为 <code>yield</code> 模式，以减少内存占用。</p></li><li><p>在执行如上两个操作之前，需要将数据处理代码封装成<code>load_data</code> 函数，方便后续调用。<code>load_data</code> 有三种模型：<code>train</code> 、<code>valid</code>、<code>eval</code>,分别对应返回的数据集时训练集、验证集和测试集。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">imgs, labels = train_set[<span class="hljs-number">0</span>], train_set[<span class="hljs-number">1</span>]<br>print(<span class="hljs-string">&quot;训练数据集数量：&quot;</span>, <span class="hljs-built_in">len</span>(imgs))<br><span class="hljs-comment"># 获得数据集长度</span><br>imgs_length = <span class="hljs-built_in">len</span>(imgs)<br><span class="hljs-comment"># 定义数据集每个数据的序号，根据序号读取数据</span><br>index_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(imgs_length))<br><span class="hljs-comment"># 读入数据时用到的批次大小</span><br>BATCHSIZE = <span class="hljs-number">100</span><br><span class="hljs-comment"># 随机打乱训练数据的索引序号</span><br>random.shuffle(index_list)<br><br><span class="hljs-comment"># 定义数据生成器，返回批次数据</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_generator</span>():</span><br>    <br>    imgs_list = []<br>    labels_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> index_list:<br>        <span class="hljs-comment"># 将数据处理成期望的格式，比如类型为 float32，shape为 [1, 28, 28]</span><br>        img = np.reshape(imgs[i], [<span class="hljs-number">1</span>, IMG_ROWS, IMG_COLS]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>        label = np.reshape(labels[i], [<span class="hljs-number">1</span>]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>        imgs_list.append(img)<br>        labels_list.append(label)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(imgs_list) == BATCHSIZE:<br>            <span class="hljs-comment"># 获得一个 batch_size 的数据，并返回</span><br>            <span class="hljs-keyword">yield</span> np.array(imgs_list), np.array(labels_list)<br>            <span class="hljs-comment"># 清空数据读取列表</span><br>            imgs_list = []<br>            labels_list = []<br>            <br>     <span class="hljs-comment"># 如果剩余数据的数目小于 BATCHSIZE，</span><br>     <span class="hljs-comment"># 则剩余数据一个构成一个大小为 len(imgs_list) 的 mini-batch</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(imgs_list) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">yield</span> np.array(imgs_list), np.array(labels_list)<br>    <span class="hljs-keyword">return</span> data_generator<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 声明数据读取函数，从训练集中读取数据</span><br>train_loader = data_generetor<br><span class="hljs-comment"># 以迭代的形式读取数据</span><br><span class="hljs-keyword">for</span> batch_id, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader()):<br>    image_data, label_data = data<br>    <span class="hljs-keyword">if</span> batch_id == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 打印数据 shape 和类型</span><br>        print(<span class="hljs-string">&quot;打印第一个batch数据的维度&quot;</span>)<br>        print(<span class="hljs-string">&quot;图像维度：&#123;&#125;，标签维度：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(image_data.shape, label_data.shape))<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="检验数据有效性"><a href="#检验数据有效性" class="headerlink" title="检验数据有效性"></a>检验数据有效性</h2><p>在实际应用中，原始数据可能存在标注不准确、数据杂乱或格式不统一等情况。因此在完成数据处理流程后，还需要进行数据校验，一般有两种方式：</p><ul><li>机器校验：加入一些校验和清理数据的操作。</li><li>人工校验：先打印数据输出结果，观察是否是设置的格式；再从训练的结果验证数据处理和读取的有效性。</li></ul><h3 id="机器校验"><a href="#机器校验" class="headerlink" title="机器校验"></a>机器校验</h3><p>如果数据集中的图片数量和标签数量不等，说明数据逻辑存在问题，可使用 <code>assert</code> 语句校验图像数量和标签数据是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">imgs_length = <span class="hljs-built_in">len</span>(imgs)<br><br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(imgs) == <span class="hljs-built_in">len</span>(labels), \<br><span class="hljs-string">&quot;length of train_imgs(&#123;&#125;) should be the same as train_labels(&#123;&#125;)&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(imgs), <span class="hljs-built_in">len</span>(labels))<br></code></pre></td></tr></table></figure><h3 id="人工校验"><a href="#人工校验" class="headerlink" title="人工校验"></a>人工校验</h3><p>人工校验是指打印数据输出结果，观察是否是预期的格式。实现数据处理和加载函数后，我们可以调用它读取一次数据，观察数据的 shape 和类型是否与函数中设置的一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 声明数据读取函数，从训练集中读取数据</span><br>train_loader = data_generator<br><span class="hljs-comment"># 以迭代的形式读取数据</span><br><span class="hljs-keyword">for</span> batch_id, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader()):<br>    image_data, label_data = data<br>    <span class="hljs-keyword">if</span> batch_id == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 打印数据shape和类型</span><br>        print(<span class="hljs-string">&quot;打印第一个batch数据的维度，以及数据的类型:&quot;</span>)<br>        print(<span class="hljs-string">&quot;图像维度: &#123;&#125;, 标签维度: &#123;&#125;, 图像数据类型: &#123;&#125;, 标签数据类型: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(image_data.shape, label_data.shape, <span class="hljs-built_in">type</span>(image_data), <span class="hljs-built_in">type</span>(label_data)))<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="封装数据读取与处理函数"><a href="#封装数据读取与处理函数" class="headerlink" title="封装数据读取与处理函数"></a>封装数据读取与处理函数</h2><p>从读取数据、划分数据集、到打乱训练数据、构建数据读取器以及数据校验，完成了一整套一般性的数据处理流程，下面将这些步骤放在一个函数中实现，方便在神经网络训练时直接调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_data</span>(<span class="hljs-params">mode=<span class="hljs-string">&#x27;train&#x27;</span></span>):</span><br>    datafile = <span class="hljs-string">&#x27;./work/mnist.json.gz&#x27;</span><br>    print(<span class="hljs-string">&#x27;loading mnist dataset from &#123;&#125;......&#x27;</span>.<span class="hljs-built_in">format</span>(datafile))<br>    <span class="hljs-comment"># 加载 json 数据文件</span><br>    data = json.load(gzip.<span class="hljs-built_in">open</span>(datafile))<br>    print(<span class="hljs-string">&#x27;mnist dataset load done&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 读取到的数据区分数据集，验证集，测试集</span><br>    train_set, val_set, eval_set = data<br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;train&#x27;</span>:<br>        <span class="hljs-comment"># 获得训练数据集</span><br>        imgs, labels = train_set[<span class="hljs-number">0</span>], train_set[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">elif</span> mode == <span class="hljs-string">&#x27;valid&#x27;</span>:<br>        <span class="hljs-comment"># 获得验证数据集</span><br>        imgs, lables = val_set[<span class="hljs-number">0</span>], val_set[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">elif</span> mode == <span class="hljs-string">&#x27;eval&#x27;</span>:<br>        <span class="hljs-comment"># 获得测试数据集</span><br>        imgs, labels = eval_set[<span class="hljs-number">0</span>], eval_set[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;mode can only be one of [&#x27;train&#x27;, &#x27;valid&#x27;, &#x27;eval&#x27;]&quot;</span>)<br>    print(<span class="hljs-string">&quot;训练数据集数量&quot;</span>, <span class="hljs-built_in">len</span>(imgs))<br>    <br>    <span class="hljs-comment"># 校验数据</span><br>    imgs_length = <span class="hljs-built_in">len</span>(imgs)<br>    <br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(imgs) == <span class="hljs-built_in">len</span>(labels),\<br>    <span class="hljs-string">&quot;lengeh of train_imgs(&#123;&#125;) should be the same as train_labels(&#123;&#125;)&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(imgs), <span class="hljs-built_in">len</span>(lables))<br>        <br>    <span class="hljs-comment"># 获得数据集长度</span><br>    imgs_length = <span class="hljs-built_in">len</span>(imgs)<br>    <br>    <span class="hljs-comment"># 定义数据集每个数据的序号，根据序号读取数据</span><br>    index_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(imgs_length))<br>    <span class="hljs-comment"># 读入数据时用到的批次大小</span><br>    BATCHSIZE = <span class="hljs-number">100</span><br>    <br>    <span class="hljs-comment"># 定义数据生成器</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_generator</span>():</span><br>        <span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;train&#x27;</span>:<br>            <span class="hljs-comment"># 训练模式下打乱数据</span><br>            random.shuffle(index_list)<br>        imgs_list = []<br>        lables_list = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> index_list:<br>            <span class="hljs-comment"># 将数据处理成希望的格式，比如类型为 float32, shape 为[1, 28, 28]</span><br>            img = np.reshape(imgs[i], [<span class="hljs-number">1</span>, IMG_ROWS, IMG_COLS]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>            label = np.reshape(labels[i], [<span class="hljs-number">1</span>]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>            imgs_list.append(img)<br>            labels_list.append(label)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(imgs_list) == BATCHSIZE:<br>                 <span class="hljs-comment"># 获得一个 batch_size 的数据，并返回</span><br>                    <span class="hljs-keyword">yield</span> np.array(imgs_list), np.array(labels_list)<br>                    <span class="hljs-comment"># 清空数据读取列表</span><br>                    imgs_list = []<br>                    labels_list = []<br><br>             <span class="hljs-comment"># 如果剩余数据的数目小于 BATCHSIZE，</span><br>             <span class="hljs-comment"># 则剩余数据一个构成一个大小为 len(imgs_list) 的 mini-batch</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(imgs_list) &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">yield</span> np.array(imgs_list), np.array(labels_list)<br>            <span class="hljs-keyword">return</span> data_generator<br></code></pre></td></tr></table></figure><p>下面定义一层神经网络，利用定义好的数据处理函数，完成神经网络的训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据处理部分之后的代码，数据读取的部分调用load_data函数</span><br><span class="hljs-comment"># 定义网络结构，同上一节所使用的网络结构</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MNIST</span>(<span class="hljs-params">fluid.dygraph.Layer</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(MNIST, self).__init__()<br>        self.fc = Linear(input_dim=<span class="hljs-number">784</span>, output_dim=<span class="hljs-number">1</span>, act=<span class="hljs-literal">None</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, inputs</span>):</span><br>        inputs = fluid.layers.reshape(inputs, (-<span class="hljs-number">1</span>, <span class="hljs-number">784</span>))<br>        outputs = self.fc(inputs)<br>        <span class="hljs-keyword">return</span> outputs<br><br><span class="hljs-comment"># 训练配置，并启动训练过程</span><br><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    model = MNIST()<br>    model.train()<br>    <span class="hljs-comment">#调用加载数据的函数</span><br>    train_loader = load_data(<span class="hljs-string">&#x27;train&#x27;</span>)<br>    optimizer = fluid.optimizer.SGDOptimizer(learning_rate=<span class="hljs-number">0.001</span>, parameter_list=model.parameters())<br>    EPOCH_NUM = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">for</span> epoch_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(EPOCH_NUM):<br>        <span class="hljs-keyword">for</span> batch_id, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader()):<br>            <span class="hljs-comment">#准备数据，变得更加简洁</span><br>            image_data, label_data = data<br>            image = fluid.dygraph.to_variable(image_data)<br>            label = fluid.dygraph.to_variable(label_data)<br>            <br>            <span class="hljs-comment">#前向计算的过程</span><br>            predict = model(image)<br>            <br>            <span class="hljs-comment">#计算损失，取一个批次样本损失的平均值</span><br>            loss = fluid.layers.square_error_cost(predict, label)<br>            avg_loss = fluid.layers.mean(loss)<br>            <br>            <span class="hljs-comment">#每训练了200批次的数据，打印下当前Loss的情况</span><br>            <span class="hljs-keyword">if</span> batch_id % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:<br>                print(<span class="hljs-string">&quot;epoch: &#123;&#125;, batch: &#123;&#125;, loss is: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch_id, batch_id, avg_loss.numpy()))<br>            <br>            <span class="hljs-comment">#后向传播，更新参数的过程</span><br>            avg_loss.backward()<br>            optimizer.minimize(avg_loss)<br>            model.clear_gradients()<br><br>    <span class="hljs-comment">#保存模型参数</span><br>    fluid.save_dygraph(model.state_dict(), <span class="hljs-string">&#x27;mnist&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="异步数据读取"><a href="#异步数据读取" class="headerlink" title="异步数据读取"></a>异步数据读取</h2><p>上面提到的数据读取采用的是同步数据读取方式。对于样本量较大、数据读取较慢的场景，建议采用异步数据读取方式。异步读取数据时，数据读取和模型训练并行执行，从而加快了数据读取速度，牺牲一小部分内存换取数据读取效率的提升。</p><ul><li><strong>同步数据读取</strong>：数据读取与模型训练串行。当模型需要数据时，才运行数据读取函数获得当前批次的数据。在读取数据期间，模型一直等待数据读取结束才进行训练，数据读取速度相对较慢。</li><li><strong>异步数据读取</strong>：数据读取和模型训练并行。读取到的数据不断的放入缓存区，无需等待模型训练就可以启动下一轮数据读取。当模型训练完一个批次后，不用等待数据读取过程，直接从缓存区获得下一批次数据进行训练，从而加快了数据读取速度。</li><li><strong>异步队列</strong>：数据读取和模型训练交互的仓库，二者均可以从仓库中读取数据，它的存在使得两者的工作节奏可以解耦。</li></ul><p>使用飞桨实现异步数据读取非常简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义数据读取后存放的位置，CPU或者GPU，这里使用CPU</span><br><span class="hljs-comment"># place = fluid.CUDAPlace(0) 时，数据才读取到GPU上</span><br>place = fluid.CPUPlace()<br><span class="hljs-keyword">with</span> fluid.dygraph.guard(place):<br>    <span class="hljs-comment"># 声明数据加载函数，使用训练模式</span><br>    train_loader = load_data(mode=<span class="hljs-string">&#x27;train&#x27;</span>)<br>    <span class="hljs-comment"># 定义DataLoader对象用于加载Python生成器产生的数据</span><br>    data_loader = fluid.io.DataLoader.from_generator(capacity=<span class="hljs-number">5</span>, return_list=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 设置数据生成器</span><br>    data_loader.set_batch_generator(train_loader, places=place)<br>    <span class="hljs-comment"># 迭代的读取数据并打印数据的形状</span><br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_loader):<br>        image_data, label_data = data<br>        print(i, image_data.shape, label_data.shape)<br>        <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-number">5</span>:<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>与同步数据读取相比，异步数据读取仅增加了三行代码，如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">place = fluid.CPUPlace()<br><br><span class="hljs-comment"># 设置读取的数据是放在CPU还是GPU上。</span><br><br>data_loader = fluid.io.DataLoader.from_generator(capacity=<span class="hljs-number">5</span>, return_list=<span class="hljs-literal">True</span>) <br><br><span class="hljs-comment"># 创建一个DataLoader对象用于加载Python生成器产生的数据。数据会由Python线程预先读取，并异步送入一个队列中。</span><br><br>data_loader.set_batch_generator(train_loader, place) <br><br><span class="hljs-comment"># 用创建的DataLoader对象设置一个数据生成器set_batch_generator，输入的参数是一个Python数据生成器train_loader和服务器资源类型place（标明CPU还是GPU）</span><br></code></pre></td></tr></table></figure><p>fluid.io.DataLoader.from_generator参数名称和含义如下：</p><ul><li>feed_list：仅在PaddlePaddle静态图中使用，动态图中设置为“None”，本教程默认使用动态图的建模方式；</li><li>capacity：表示在DataLoader中维护的队列容量，如果读取数据的速度很快，建议设置为更大的值；</li><li>use_double_buffer：是一个布尔型的参数，设置为“True”时，Dataloader会预先异步读取下一个batch的数据并放到缓存区；</li><li>iterable：表示创建的Dataloader对象是否是可迭代的，一般设置为“True”；</li><li>return_list：在动态图模式下需要设置为“True”。</li></ul><p>异步数据读取并训练的完整案例代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    model = MNIST()<br>    model.train()<br>    <span class="hljs-comment">#调用加载数据的函数</span><br>    train_loader = load_data(<span class="hljs-string">&#x27;train&#x27;</span>)<br>    <span class="hljs-comment"># 创建异步数据读取器</span><br>    place = fluid.CPUPlace()<br>    data_loader = fluid.io.DataLoader.from_generator(capacity=<span class="hljs-number">5</span>, return_list=<span class="hljs-literal">True</span>)<br>    data_loader.set_batch_generator(train_loader, places=place)<br>    <br>    optimizer = fluid.optimizer.SGDOptimizer(learning_rate=<span class="hljs-number">0.001</span>, parameter_list=model.parameters())<br>    EPOCH_NUM = <span class="hljs-number">3</span><br>    <span class="hljs-keyword">for</span> epoch_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(EPOCH_NUM):<br>        <span class="hljs-keyword">for</span> batch_id, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_loader):<br>            image_data, label_data = data<br>            image = fluid.dygraph.to_variable(image_data)<br>            label = fluid.dygraph.to_variable(label_data)<br>            <br>            predict = model(image)<br>            <br>            loss = fluid.layers.square_error_cost(predict, label)<br>            avg_loss = fluid.layers.mean(loss)<br>            <br>            <span class="hljs-keyword">if</span> batch_id % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:<br>                print(<span class="hljs-string">&quot;epoch: &#123;&#125;, batch: &#123;&#125;, loss is: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch_id, batch_id, avg_loss.numpy()))<br>            <br>            avg_loss.backward()<br>            optimizer.minimize(avg_loss)<br>            model.clear_gradients()<br><br>    fluid.save_dygraph(model.state_dict(), <span class="hljs-string">&#x27;mnist&#x27;</span>)<br></code></pre></td></tr></table></figure><p>从异步数据读取的训练结果来看，损失函数下降与同步数据读取训练结果一致。注意，<strong>异步读取数据只在数据量规模巨大时会带来显著的性能提升，对于多数场景采用同步数据读取的方式已经足够</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Paddle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paddle AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过极简方案构建手写数字识别模型</title>
    <link href="/2021/01/29/paddle-2-1/"/>
    <url>/2021/01/29/paddle-2-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="通过极简方案构建手写数字识别模型"><a href="#通过极简方案构建手写数字识别模型" class="headerlink" title="通过极简方案构建手写数字识别模型"></a>通过极简方案构建手写数字识别模型</h1><h2 id="手写数字识别任务"><a href="#手写数字识别任务" class="headerlink" title="手写数字识别任务"></a>手写数字识别任务</h2><ul><li>任务输入：一系列手写数字图片，其中每张图片都是 28x28 的像素矩阵。</li><li>任务输出：经过了大小归一化和居中处理，输出对应的 0~9 的数字标签。</li><li>MNIST 数据集是从 NIST 的 Special Database 3（SD-3）和 Special Database 1（SD-1）构建而来。Yann LeCun 等人从 SD-1 和 SD-3 中各取一半数据作为 MNIST 训练集和测试集，其中训练集来自 250 位不同的标注员，且训练集和测试集的标注员完全不同。</li></ul><h2 id="前提条件：导入相关库"><a href="#前提条件：导入相关库" class="headerlink" title="前提条件：导入相关库"></a>前提条件：导入相关库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载飞桨和相关类库</span><br><span class="hljs-keyword">import</span> paddle<br><span class="hljs-keyword">import</span> paddle.fluid <span class="hljs-keyword">as</span> fluid<br><span class="hljs-keyword">from</span> paddle.fluid.dygraph <span class="hljs-keyword">import</span> Linear<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br></code></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>飞桨提供了多个封装好的数据集 API，涵盖计算机视觉、自然语言处理、推荐系统等多个领域，帮助读者快速完成深度学习任务。如在手写数字识别任务中，通过 <a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api_cn/data_cn/dataset_cn.html">paddle.dataset.mnist</a> 可以直接获取处理好的 MNIST 训练集、测试集，飞桨 API 支持如下常见的学术数据集：</p><ul><li>mnist</li><li>cifar</li><li>Conll05</li><li>imdb</li><li>imikolov</li><li>movielens</li><li>sentiment</li><li>uci_housing</li><li>wmt14</li><li>wmt16</li></ul><p>通过 <code>paddle.dataset.mnist.train()</code> 函数设置数据读取器，<code>batch_size</code> 设置为 8，即一个批次有 8 张图片和 8 个标签，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果～/.cache/paddle/dataset/mnist/目录下没有MNIST数据，API会自动将MINST数据下载到该文件夹下</span><br><span class="hljs-comment"># 设置数据读取器，读取MNIST数据训练集</span><br>trainset = paddle.dataset.mnist.train()<br><span class="hljs-comment"># 包装数据读取器，每次读取的数据数量设置为batch_size=8</span><br>train_reader = paddle.batch(trainset, batch_size=<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p><code>paddle.batch</code> 函数将 MNIST 数据集拆分成多个批次，通过如下代码读取第一个批次的数据内容，观察打印结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以迭代的形式读取数据</span><br><span class="hljs-keyword">for</span> batch_id, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_reader()):<br>    <span class="hljs-comment"># 获得图像数据，并转为float32类型的数组</span><br>    img_data = np.array([x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    <span class="hljs-comment"># 获得图像标签数据，并转为float32类型的数组</span><br>    label_data = np.array([x[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    <span class="hljs-comment"># 打印数据形状</span><br>    print(<span class="hljs-string">&quot;图像数据形状和对应数据为:&quot;</span>, img_data.shape, img_data[<span class="hljs-number">0</span>])<br>    print(<span class="hljs-string">&quot;图像标签形状和对应数据为:&quot;</span>, label_data.shape, label_data[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">break</span><br><br>print(<span class="hljs-string">&quot;\n打印第一个batch的第一个图像，对应标签数字为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(label_data[<span class="hljs-number">0</span>]))<br><span class="hljs-comment"># 显示第一batch的第一个图像</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>img = np.array(img_data[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>)*<span class="hljs-number">127.5</span><br>img = np.reshape(img, [<span class="hljs-number">28</span>, <span class="hljs-number">28</span>]).astype(np.uint8)<br><br>plt.figure(<span class="hljs-string">&quot;Image&quot;</span>) <span class="hljs-comment"># 图像窗口名称</span><br>plt.imshow(img)<br>plt.axis(<span class="hljs-string">&#x27;on&#x27;</span>) <span class="hljs-comment"># 关掉坐标轴为 off</span><br>plt.title(<span class="hljs-string">&#x27;image&#x27;</span>) <span class="hljs-comment"># 图像题目</span><br>plt.show()<br></code></pre></td></tr></table></figure><p>从打印结果看，从数据加载器 <code>train_reader()</code> 中读取一次数据，可以得到形状为（8, 784）的图像数据和形状为（8,）的标签数据。其中，形状中的数字 8 与设置的 <code>batch_size</code> 大小对应，784 为 MINIST 数据集中每个图像的像素大小 (28*28)。</p><p><strong>说明：</strong></p><p>飞桨将维度是 28<em>28 的手写数字图像转成向量形式存储，因此使用飞桨数据加载器读取到的手写数字图像是长度为 784（28</em>28）的向量。</p><h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><p>以类的方式组件手写数字识别的网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义 mnist 数据识别网络结构</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MNIST</span>(<span class="hljs-params">fluid.dygraph.Layer</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(MNIST， self).__init__()<br>        <br>        <span class="hljs-comment"># 定义一层全连接层，输出维度是1，激活函数为None，即不使用激活函数</span><br>        self.fc = Linear(input_dim=<span class="hljs-number">784</span>, output_dim=<span class="hljs-number">1</span>, act=<span class="hljs-literal">None</span>)<br>        <br>    <span class="hljs-comment"># 定义网络结构的前向计算过程</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, inputs</span>)</span><br>    outputs = self.fc(inputs)<br>    <span class="hljs-keyword">return</span> outputs<br><br></code></pre></td></tr></table></figure><h2 id="训练配置"><a href="#训练配置" class="headerlink" title="训练配置"></a>训练配置</h2><p>训练配置需要先生成模型实例（设为 “训练” 状态），再设置优化算法和学习率（使用随机梯度下降 SGD，学习率设置为 0.001），实现方法如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义飞桨动态图工作环境</span><br><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    <span class="hljs-comment"># 声明网络结构、</span><br>    model = MNIST()<br>    <span class="hljs-comment"># 启动训练模式</span><br>    model.train()<br>    <span class="hljs-comment"># 定义数据读取函数，数据读取 batch_size 设置为 16</span><br>    train_loader = paddle.batch(paddle.dataset.mnist.train(), batch_size=<span class="hljs-number">16</span>)<br>    <span class="hljs-comment"># 定义优化器，使用随机梯度下降SGD优化器，学习率设置为0.001</span><br>    optimizer = fluid.optimizer.SGDOptimizer(learning_rate=<span class="hljs-number">0.001</span>, parameter_list=model.parameters())<br>    <br></code></pre></td></tr></table></figure><h2 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h2><p>训练过程采用二层循环嵌套方式，训练完成后需要保存模型参数，以便后续使用。</p><ul><li>内层循环：负责整个数据集的一次遍历，遍历数据集采用分批次（batch）方式。</li><li>外层循环：定义遍历数据集的次数，本次训练中外层循环 10 次，通过参数 EPOCH_NUM 设置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过 with 语句创建一个dygraph运行的 contest</span><br><span class="hljs-comment"># 动态图下的一些操作需要在 guard 下进行</span><br><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    model = MNIST()<br>    model.train()<br>    train_loader = paddle.batch(paddle.dataset.mnist.train(), batch_size=<span class="hljs-number">16</span>)<br>    optimizer = fluid.optimizer.SGDOptimizer(learning_rate=<span class="hljs-number">0.001</span>, parameter_list=model.parameters())<br>    <br>    EPOCH_NUM = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">for</span> epoch_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(EPOCH_NUM):<br>        <span class="hljs-keyword">for</span> batch_id, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader()):<br>            <span class="hljs-comment"># 准备数据，格式需要转换成符合框架要求</span><br>            image_data = np.array([x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>            label_data = np.array([x[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># 将数据转为飞桨动态图格式</span><br>            image = fluid.dygraph.to_variable(image_data)<br>            label = fluid.dygraph.to_variable(label_data)<br>            <br>            <span class="hljs-comment"># 前向计算的过程</span><br>            predict = model(image)<br>            <br>            <span class="hljs-comment"># 计算损失，取一个批次样本损失的平均值</span><br>            loss = fluid.layers.square_error_cost(predict, label)<br>            avg_loss = fluid.layers.mean(loss)<br>            <br>            <span class="hljs-comment"># 每训练了 1000 批次的数据，打印下当前 Loss 的情况</span><br>            <span class="hljs-keyword">if</span> batch_id != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> batch_id % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>                print(<span class="hljs-string">&quot;epoch: &#123;&#125;, batch: &#123;&#125;, loss is: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch_id, batch_id, avg_loss.numpy()))<br>                <br>            <span class="hljs-comment"># 后向传播，更新参数的过程</span><br>            avg_loss.backward()<br>            optimizer.minimize(avg_loss)<br>            model.clear_gradients()<br>            <br><span class="hljs-comment"># 保存模型</span><br>fluid.save_dygraph(model.state_dict(), <span class="hljs-string">&#x27;mnist&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="模型测试"><a href="#模型测试" class="headerlink" title="模型测试"></a>模型测试</h2><p>模型测试的主要目的是验证训练好的模型是否能正确识别出数字，包括如下四步：</p><ul><li>声明实例</li><li>加载模型：加载训练过程中保存的模型参数。</li><li>灌入数据：将测试样本传入模型，模型的状态设置为校验状态（eval），显式告诉框架我们接下来只会使用前向计算的流程，不会计算梯度和梯度反向传播。</li><li>获取预测结果，取整后作为预测标签输出。</li></ul><p>在模型测试之前，需要先从 ‘./work/example_0.jpg’ 文件中读取样例图片，并进行归一化处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入图像读取第三方库</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.image <span class="hljs-keyword">as</span> mpimg<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 读取图像</span><br>img1 = cv2.imread(<span class="hljs-string">&#x27;./work/example_0.png&#x27;</span>)<br>example = mpimg.imread(<span class="hljs-string">&#x27;./work/example_0.png&#x27;</span>)<br><br><span class="hljs-comment"># 显示图像</span><br>plt.imshow(example)<br>plt.show()<br>im = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./work/example_0.png&#x27;</span>).convert(<span class="hljs-string">&#x27;L&#x27;</span>)<br>print(np.array(im).shape)<br>im = im.resize((<span class="hljs-number">28</span>, <span class="hljs-number">28</span>), Image.ANTIALIAS)<br>plt.imshow(im)<br>plt.show()<br>print(np.array(im).shape)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取一张本地的样例图片，转变成模型输入的格式</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_image</span>(<span class="hljs-params">img_path</span>):</span><br>    <span class="hljs-comment"># 从img_path中读取图像，并转为灰度图</span><br>    im = Image.<span class="hljs-built_in">open</span>(img_path).convert(<span class="hljs-string">&#x27;L&#x27;</span>)<br>    print(np.array(im))<br>    im = im.resize((<span class="hljs-number">28</span>, <span class="hljs-number">28</span>), Image.ANTIALIAS)<br>    im = np.array(im).reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).astype(np.float32)<br>    <span class="hljs-comment"># 将图像归一化，保持和数据集的数据范围一致</span><br>    im = <span class="hljs-number">1</span> - im / <span class="hljs-number">127.5</span><br>    <span class="hljs-keyword">return</span> im<br><br><span class="hljs-comment"># 定义预测过程</span><br><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    model = MNIST()<br>    params_file_path = <span class="hljs-string">&#x27;mnist&#x27;</span><br>    img_path = <span class="hljs-string">&#x27;./work/example_0.png&#x27;</span><br>    <br>    <span class="hljs-comment"># 加载模型参数</span><br>    model_dict, _ = fluid.load_dygraph(<span class="hljs-string">&#x27;mnist&#x27;</span>)<br>    model.load_dict(model_dict)<br>    <span class="hljs-comment"># 灌入数据</span><br>    model.<span class="hljs-built_in">eval</span>()<br>    tensor_img = load_image(img_path)<br>    result = model(fluid.dygraph.to_variable(tensor_img))<br>    <br>    <span class="hljs-comment"># 预测输出取整，即为预测的数字，打印结果</span><br>    print(<span class="hljs-string">&quot;本次预测的数字是&quot;</span>,result.numpy().astype(<span class="hljs-string">&#x27;int32&#x27;</span>))<br></code></pre></td></tr></table></figure><p>从打印结果来看，模型预测出的数字是与实际输出的图片的数字不一致。这里只是验证了一个样本的情况，如果我们尝试更多的样本，可发现许多数字图片识别结果是错误的。因此完全复用房价预测的实验并不适用于手写数字识别任务！</p><p>接下来我们会对手写数字识别实验模型进行逐一改进，直到获得令人满意的结果。</p>]]></content>
    
    
    <categories>
      
      <category>Paddle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paddle AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用飞桨构建波士顿房价预测模型</title>
    <link href="/2021/01/29/paddle-1-3/"/>
    <url>/2021/01/29/paddle-1-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用飞桨构建波士顿房价预测模型"><a href="#使用飞桨构建波士顿房价预测模型" class="headerlink" title="使用飞桨构建波士顿房价预测模型"></a>使用飞桨构建波士顿房价预测模型</h1><h2 id="加载飞桨、Numpy-和相关类库"><a href="#加载飞桨、Numpy-和相关类库" class="headerlink" title="加载飞桨、Numpy 和相关类库"></a>加载飞桨、Numpy 和相关类库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> paddle<br><span class="hljs-keyword">import</span> paddle.fluid <span class="hljs-keyword">as</span> fluid<br><span class="hljs-keyword">import</span> paddle.fluid.dygraph <span class="hljs-keyword">as</span> dygraph<br><span class="hljs-keyword">from</span> paddle.fluid.dygraph <span class="hljs-keyword">import</span> Linear<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> random<br></code></pre></td></tr></table></figure><p>代码中参数含义如下：</p><ul><li>paddle/fluid：飞桨的主库，目前大部分的实用函数均在 paddle.fluid 包内。</li><li>dygraph：动态图的类库。</li><li>Linear：神经网络的全连接层函数，即包含所有输入权重相加和激活函数的基本神经元结构。在房价预测任务中，使用只有一层的神经网络（全连接层）来实现线性回归模型。</li></ul><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_data</span>():</span><br>    <span class="hljs-comment"># 从文件导入数据</span><br>    datafile = <span class="hljs-string">&#x27;./work/housing.data&#x27;</span><br>    data = np.fromfile(datafile, sep=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <br>    <span class="hljs-comment"># 每条数据包括14项，其中前面13项是影响因素，第14项是相应的房屋价格中位数</span><br>    feature_names = [ <span class="hljs-string">&#x27;CRIM&#x27;</span>, <span class="hljs-string">&#x27;ZN&#x27;</span>, <span class="hljs-string">&#x27;INDUS&#x27;</span>, <span class="hljs-string">&#x27;CHAS&#x27;</span>, <span class="hljs-string">&#x27;NOX&#x27;</span>, <span class="hljs-string">&#x27;RM&#x27;</span>, <span class="hljs-string">&#x27;AGE&#x27;</span>, \<br>                      <span class="hljs-string">&#x27;DIS&#x27;</span>, <span class="hljs-string">&#x27;RAD&#x27;</span>, <span class="hljs-string">&#x27;TAX&#x27;</span>, <span class="hljs-string">&#x27;PTRATIO&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;LSTAT&#x27;</span>, <span class="hljs-string">&#x27;MEDV&#x27;</span> ]<br>    feature_num = <span class="hljs-built_in">len</span>(feature_names)<br>    <br>    <span class="hljs-comment"># 将原始数据进行Reshape，变成[N, 14]这样的形状</span><br>    data = data.reshape([data.shape[<span class="hljs-number">0</span>] // feature_num, feature_num])<br>    <br>    <span class="hljs-comment"># 将原数据集拆分成训练集和测试集</span><br>    <span class="hljs-comment"># 这里使用80%的数据做训练，20%的数据做测试</span><br>    <span class="hljs-comment"># 测试集和训练集必须是没有交集的</span><br>    ratio = <span class="hljs-number">0.8</span><br>    offset = <span class="hljs-built_in">int</span>(data.shape[<span class="hljs-number">0</span>] * ratio)<br>    training_data = data[:offset]<br>    <br>    <span class="hljs-comment"># 计算train数据集的最大值，最小值，平均值</span><br>    maximums, minmums, avgs = training_data.<span class="hljs-built_in">max</span>(axis=<span class="hljs-number">0</span>), training_data.<span class="hljs-built_in">min</span>(axis=<span class="hljs-number">0</span>),<br>    training_data.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>) / training_data.shape[<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-comment"># 记录数据的归一化参数，在预测时对数据做归一化</span><br>    <span class="hljs-keyword">global</span> max_values<br>    <span class="hljs-keyword">global</span> min_values<br>    <span class="hljs-keyword">global</span> avg_values<br>    max_values = maximums<br>    min_values = minimums<br>    avg_values = avgs<br>    <br>    <span class="hljs-comment"># 对数据进行归一化处理</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(feature_num):<br>        data[:, i] = (data[:, i] - avgs[i]) / (maxmums[i] - minimums[i])<br>        <br>    <span class="hljs-comment"># 训练集和测试集的划分比例</span><br>    training_data = data[:offset]<br>    test_data = data[offset:]<br>    <span class="hljs-keyword">return</span> training_data, test_data<br></code></pre></td></tr></table></figure><h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><p>模型定义的实质是定义线性回归的网络结构，飞桨建议通过创建Python类的方式完成模型网络的定义，即定义<code>init</code>函数和<code>forward</code>函数。<code>forward</code>函数是框架指定实现前向计算逻辑的函数，程序在调用模型实例时会自动执行forward方法。在<code>forward</code>函数中使用的网络层需要在<code>init</code>函数中声明。</p><p>实现过程分如下两步：</p><ol><li><strong>定义init函数</strong>：在类的初始化函数中声明每一层网络的实现函数。在房价预测模型中，只需要定义一层全连接层，模型结构和<a href="https://aistudio.baidu.com/aistudio/projectdetail/555240">《使用Python和Numpy构建神经网络模型》章节</a>模型保持一致。</li><li><strong>定义forward函数</strong>：构建神经网络结构，实现前向计算过程，并返回预测结果，在本任务中返回的是房价预测结果。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Regressor</span>(<span class="hljs-params">fluid.dygraph.Layer</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(Regressor, self).__init__()<br>        <br>        <span class="hljs-comment"># 定义一层全连接层，输出维度时1，激活函数为 None，即不使用激活函数</span><br>        self.fc = Linear(input_dim=<span class="hljs-number">3</span>, output_dim=<span class="hljs-number">1</span>, act=<span class="hljs-literal">None</span>)<br>        <br>    <span class="hljs-comment"># 网络的前向计算函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, inputs</span>):</span><br>        x = self.fc(inputs)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><h2 id="训练配置"><a href="#训练配置" class="headerlink" title="训练配置"></a>训练配置</h2><p>训练配置过程包括四步：</p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/96075d4df5ae4e01ac1491ebf176fa557bd122b646ba49238f65c9b38a98cab4" alt=""></p><ol><li>以<code>guard</code>函数指定运行训练的机器资源，表明在<code>with</code>作用域下的程序均执行在本机的CPU资源上。<code>dygraph.guard</code>表示在<code>with</code>作用域下的程序会以飞桨动态图的模式执行（实时执行）。</li><li>声明定义好的回归模型Regressor实例，并将模型的状态设置为训练。</li><li>使用load_data函数加载训练数据和测试数据。</li><li>设置优化算法和学习率，优化算法采用随机梯度下降<a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api_cn/optimizer_cn/SGDOptimizer_cn.html#cn-api-fluid-optimizer-sgdoptimizer">SGD</a>，学习率设置为0.01。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义飞桨动态图的工作环境</span><br><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    <span class="hljs-comment"># 声明定义好的线性回归模型</span><br>    model = Regressor()<br>    <span class="hljs-comment"># 开启模型训练模式</span><br>    model.train()<br>    <span class="hljs-comment"># 加载数据</span><br>    training_data, test_data = load_data()<br>    <span class="hljs-comment"># 定义优化算法，这里使用随机梯度下降SGD</span><br>    <span class="hljs-comment"># 学习率设置为 0.01</span><br>    opt = fluid.optimizer.SGD(learning_rate=<span class="hljs-number">0.01</span>, parameter_list=model.parameters())<br>    <br></code></pre></td></tr></table></figure><p>模型实例有两种状态：训练状态<code>.train()</code>和预测状态<code>.eval()</code>。</p><p> 在上述代码中可以发现声明模型、定义优化器等操作都在<code>with</code>创建的 <a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api_cn/dygraph_cn/guard_cn.html#guard">fluid.dygraph.guard()</a>上下文环境中进行，可以理解为<code>with fluid.dygraph.guard()</code>创建了飞桨动态图的工作环境，在该环境下完成模型声明、数据转换及模型训练等操作。</p><h2 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h2><p>训练过程采用二层循环嵌套方式：</p><ul><li><p>内层循环：<strong>负责整个数据集的一次遍历</strong>，采用<strong>分批次方式（batch）</strong>。假设数据集样本数量为 1000，一个批次有 10 个样本，则遍历一次数据集的批次数量是 1000/10=100，即内层循环需要执行 100 次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> iter_id, mini_batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(minibatches):<br></code></pre></td></tr></table></figure></li><li><p>外层循环：定义遍历数据集的次数，通过参数<code>EPOCH_NUM</code>设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(EPOCH_NUM)<br></code></pre></td></tr></table></figure><p>说明：</p></li></ul><p>batch的取值会影响模型训练效果。bacth过大，会增大内存消耗和计算时间，且效果并不会明显提升；batch过小，每个batch的样本数据将没有统计意义。</p><p>每个内层循环都需要执行如下四个步骤：</p><ol><li>数据准备：将一个批次的数据转变为<code>np.array</code>和内置格式。</li><li>前向计算：将一个批次的样本数据灌入网络中，计算输出结果。</li><li>计算损失函数：以前向计算结果和真实房价作为输入，通过损失函数<a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api_cn/layers_cn/square_error_cost_cn.html#square-error-cost/">square_error_cost</a>计算出损失函数值（Loss）。</li><li>反向传播：执行梯度反向传播<code>backward</code>函数，即从后到前逐层计算每一层的梯度，并根据设置的优化算法更新参数<code>opt.minimize</code>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> dygraph.guard(fluid.CPUPlace()):<br>    EPOCH_NUM = <span class="hljs-number">10</span> <span class="hljs-comment"># 设置外层循环次数</span><br>    BATCH_SIZE = <span class="hljs-number">10</span> <span class="hljs-comment"># 设置 batch 大小</span><br>    <br>    <span class="hljs-comment"># 定义外层循环</span><br>    <span class="hljs-keyword">for</span> epoch_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(EPOCH_NUM):<br>        <span class="hljs-comment"># 在每轮迭代开始之前，将训练数据的顺序随机的打乱</span><br>        np.random.shuffle(training_data)<br>        <span class="hljs-comment"># 将训练数据进行拆分，每个batch包含 10 条数据</span><br>        mini_batches = [training_data[k:k+BATCH_SIZE] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(training_data), BATCH_SIZE)]<br>        <span class="hljs-comment"># 定义内层循环</span><br>        <span class="hljs-keyword">for</span> iter_id, mini_batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(mini_batches):<br>            x = np.array(mini_batch[:, :-<span class="hljs-number">1</span>]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>) <span class="hljs-comment"># 获得当前批次训练数据</span><br>            y = np.array(mini_batch[:, -<span class="hljs-number">1</span>:]).astype(<span class="hljs-string">&#x27;float32&#x27;</span>) <span class="hljs-comment"># 获得当前批次训练标签（真实房价）</span><br>            <span class="hljs-comment"># 将 numpy 数据转为飞桨动态图 variable 形式</span><br>            house_features = dygraph.to_variable(x)<br>            prices = dygraph.to_variable(y)<br>            <br>            <span class="hljs-comment"># 前向计算</span><br>            predict = model(house_features)<br>            <br>            <span class="hljs-comment"># 计算损失</span><br>            loss = fluid.layers.square_error_cost(predict, label=prices)<br>            avg_loss = fluid.layers.mean(loss)<br>            <span class="hljs-keyword">if</span> iter_id % <span class="hljs-number">20</span> == <span class="hljs-number">0</span>:<br>                print(<span class="hljs-string">&quot;epoch: &#123;&#125;,iter: &#123;&#125;, loss is: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch_id, iter_id, avg_loss.numpy()))<br>                <br>            <span class="hljs-comment"># 反向传播</span><br>            avg_loss.backward()<br>            <span class="hljs-comment"># 最小化loss，更新参数</span><br>            opt.minimize(avg_loss)<br>            <span class="hljs-comment"># 清楚梯度</span><br>            model.clear_gradients()<br>            <br><span class="hljs-comment"># 保存模型</span><br>fluid.save_dygraph(model.state_dict(), <span class="hljs-string">&#x27;LR_model&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="保存并测试模型"><a href="#保存并测试模型" class="headerlink" title="保存并测试模型"></a>保存并测试模型</h2><h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><p>将模型当前的参数数据<code>model.state_dict()</code>保存到文件中（通过参数指定保存的文件名 LR_model），以备预测或校验的程序调用，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义飞桨动态图工作环境</span><br><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    <span class="hljs-comment"># 保存模型参数，文件名为 LR_model</span><br>    fluid.save_dygraph(model.state_dict(), <span class="hljs-string">&#x27;LR_model&#x27;</span>)<br>    print(<span class="hljs-string">&quot;模型保存成功，模型参数保存在LR_model中&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h3><p>下面我们选择一条数据样本，测试下模型的预测效果。测试过程和在应用场景中使用模型的过程一致，主要可分成如下三个步骤：</p><ol><li>配置模型预测的机器资源。本案例默认使用本机，因此无需写代码指定。</li><li>将训练好的模型参数加载到模型实例中。由两个语句完成，第一句是从文件中读取模型参数；第二句是将参数内容加载到模型。加载完毕后，需要将模型的状态调整为<code>eval()</code>（校验）。上文中提到，训练状态的模型需要同时支持前向计算和反向传导梯度，模型的实现较为臃肿，而校验和预测状态的模型只需要支持前向计算，模型的实现更加简单，性能更好。</li><li>将待预测的样本特征输入到模型中，打印输出的预测结果。</li></ol><p>通过<code>load_one_example</code>函数实现从数据集中抽一条样本作为测试样本，具体实现代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_one_example</span>(<span class="hljs-params">data_dir</span>):</span><br>    f = <span class="hljs-built_in">open</span>(data_dir, <span class="hljs-string">&#x27;r&#x27;</span>)<br>    datas = f.readlines()<br>    <span class="hljs-comment"># 选择倒数第10条数据用于测试</span><br>    tmp = datas[-<span class="hljs-number">10</span>]<br>    tmp = tmp.strip().split()<br>    one_data = [<span class="hljs-built_in">float</span>(v) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> tmp]<br>    <br>    <span class="hljs-comment"># 对数据进行归一化处理</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(one_data)-<span class="hljs-number">1</span>):<br>        one_data[i] = (one_data[i] - avg_values[i]) / (max_values[i] - min_values[i])<br>        <br>    data = np.reshape(np.array(one_data[:-<span class="hljs-number">1</span>]), [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]).astype(np.float32)<br>    label = one_data[-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> data, label<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> dygraph.guard():<br>    <span class="hljs-comment"># 参数为保存模型参数的文件地址</span><br>    model_dict, _ = fluid.load_dygraph(<span class="hljs-string">&#x27;LR_model&#x27;</span>)<br>    model.load_dict(model_dict)<br>    model.<span class="hljs-built_in">eval</span>()<br>    <br>    <span class="hljs-comment"># 参数为数据集的文件地址</span><br>    test_data, label = load_one_example(<span class="hljs-string">&#x27;./work/housing.data&#x27;</span>)<br>    <span class="hljs-comment"># 将数据转为动态图的 variable 格式</span><br>    test_data = dygraph.to_variable(test_data)<br>    results = model(test_data)<br>    <br>    <span class="hljs-comment"># 对结果进行反归一化处理</span><br>    results = results * (max_values[-<span class="hljs-number">1</span>] - min_values[-<span class="hljs-number">1</span>]) + avg_values[-<span class="hljs-number">1</span>]<br>    print(<span class="hljs-string">&quot;Inference result is &#123;&#125;, the corresponding label is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(results.numpy(), label))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Paddle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paddle AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Python 语言和 Numpy 库来构建神经网络模型</title>
    <link href="/2021/01/27/paddle-1-2/"/>
    <url>/2021/01/27/paddle-1-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用-Python-语言和-Numpy-库来构建神经网络模型"><a href="#使用-Python-语言和-Numpy-库来构建神经网络模型" class="headerlink" title="使用 Python 语言和 Numpy 库来构建神经网络模型"></a>使用 Python 语言和 Numpy 库来构建神经网络模型</h1><h2 id="波士顿房价预测任务"><a href="#波士顿房价预测任务" class="headerlink" title="波士顿房价预测任务"></a>波士顿房价预测任务</h2><p>对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。</p><h3 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h3><p>假设房价和各影响因素之间能够用线性关系来描述：</p><script type="math/tex; mode=display">y=∑j=1Mxjwj+by = {\sum_{j=1}^Mx_j w_j} + b*y*=*j*=1∑*M**x**j**w**j*+*b*</script><p>模型的求解即是通过数据拟合出每个$wjw_j<em>w**j</em>$和$bb<em>b</em>$。其中，$wjw_j<em>w**j</em>$和$bb<em>b</em>$ 分别表示该线性模型的权重和偏置。一维情况下，$wjw_j<em>w**j</em> $和 $bb<em>b</em> $是直线的斜率和截距。</p><p>线性回归模型使用均方误差作为损失函数（Loss），用以衡量预测房价和真实房价的差异，公式如下：</p><script type="math/tex; mode=display">MSE=1n∑i=1n(Yi^−Yi)2</script><h3 id="线性回归模型的神经网络结构"><a href="#线性回归模型的神经网络结构" class="headerlink" title="线性回归模型的神经网络结构"></a>线性回归模型的神经网络结构</h3><p>神经网络的标准结构中每个神经元由加权和与非线性变换构成，然后将多个神经元分层的摆放并连接形成神经网络。线性回归模型可以认为是神经网络模型的一种极简特例，是一个只有加权和、没有非线性变换的神经元（无需形成网络）。</p><h2 id="构建波士顿房价预测任务的神经网络模型"><a href="#构建波士顿房价预测任务的神经网络模型" class="headerlink" title="构建波士顿房价预测任务的神经网络模型"></a>构建波士顿房价预测任务的神经网络模型</h2><p>不同场景的深度学习模型具备一定的通用性，五个步骤即可完成模型的构建和训练：</p><ol><li>数据处理：从本地或URL读取数据，并完成预处理操作（如数据校验、格式转化等），保证模型可读取。</li><li>模型设计：网络结构设计，相当于模型的假设空间，即模型能够表达的关系集合。</li><li>训练配置：设定模型采用的寻解算法，即优化器，并指定计算资源。</li><li>训练过程：循环调用训练过程，每轮都包括前向计算、损失函数（优化目标）和后向传播三个步骤。</li><li>模型保存：将训练好的模型保存，模型预测时调用</li></ol><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>数据处理包括五个部分：数据导入、数据形状变化、数据集分割、数据归一化和封装<code>load_data</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_data</span>():</span><br>    <span class="hljs-comment"># 从文件导入数据</span><br>    datafile = <span class="hljs-string">&#x27;./work/housing.data&#x27;</span><br>    data = np.fromfile(datafile, sep=<span class="hljs-string">&#x27; &#x27;</span>)<br><br>    <span class="hljs-comment"># 每条数据包括14项，其中前面13项是影响因素，第14项是相应的房屋价格中位数</span><br>    feature_names = [ <span class="hljs-string">&#x27;CRIM&#x27;</span>, <span class="hljs-string">&#x27;ZN&#x27;</span>, <span class="hljs-string">&#x27;INDUS&#x27;</span>, <span class="hljs-string">&#x27;CHAS&#x27;</span>, <span class="hljs-string">&#x27;NOX&#x27;</span>, <span class="hljs-string">&#x27;RM&#x27;</span>, <span class="hljs-string">&#x27;AGE&#x27;</span>, \<br>                      <span class="hljs-string">&#x27;DIS&#x27;</span>, <span class="hljs-string">&#x27;RAD&#x27;</span>, <span class="hljs-string">&#x27;TAX&#x27;</span>, <span class="hljs-string">&#x27;PTRATIO&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;LSTAT&#x27;</span>, <span class="hljs-string">&#x27;MEDV&#x27;</span> ]<br>    feature_num = <span class="hljs-built_in">len</span>(feature_names)<br><br>    <span class="hljs-comment"># 将原始数据进行Reshape，变成[N, 14]这样的形状</span><br>    data = data.reshape([data.shape[<span class="hljs-number">0</span>] // feature_num, feature_num])<br><br>    <span class="hljs-comment"># 将原数据集拆分成训练集和测试集</span><br>    <span class="hljs-comment"># 这里使用80%的数据做训练，20%的数据做测试</span><br>    <span class="hljs-comment"># 测试集和训练集必须是没有交集的</span><br>    ratio = <span class="hljs-number">0.8</span><br>    offset = <span class="hljs-built_in">int</span>(data.shape[<span class="hljs-number">0</span>] * ratio)<br>    training_data = data[:offset]<br><br>    <span class="hljs-comment"># 计算训练集的最大值，最小值，平均值</span><br>    maximums, minimums, avgs = training_data.<span class="hljs-built_in">max</span>(axis=<span class="hljs-number">0</span>), training_data.<span class="hljs-built_in">min</span>(axis=<span class="hljs-number">0</span>), \<br>                                 training_data.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>) / training_data.shape[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 对数据进行归一化处理</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(feature_num):<br>        <span class="hljs-comment">#print(maximums[i], minimums[i], avgs[i])</span><br>        data[:, i] = (data[:, i] - minimums[i]) / (maximums[i] - minimums[i])<br><br>    <span class="hljs-comment"># 训练集和测试集的划分比例</span><br>    training_data = data[:offset]<br>    test_data = data[offset:]<br>    <span class="hljs-keyword">return</span> training_data, test_data<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取数据</span><br>training_data, test_data = load_data()<br>x = training_data[:, :-<span class="hljs-number">1</span>]<br>y = training_data[:, -<span class="hljs-number">1</span>:]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看数据</span><br>print(x[<span class="hljs-number">0</span>])<br>print(y[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h3 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h3><p>模型设计是深度学习模型关键要素之一，也称为网络结构设计，相当于模型的假设空间，即实现模型 “前向计算”（从输入到输出）的过程。</p><h3 id="训练配置"><a href="#训练配置" class="headerlink" title="训练配置"></a>训练配置</h3><p>模型设计完成后，需要通过训练配置寻找模型的最优值，即通过损失函数来衡量模型的好坏。训练配置也是深度学习模型关键要素之一。</p><p>通过模型计算$x_1$表示的影响因素所对应的房价应该是$z$, 但实际数据告诉我们房价是$y$。这时我们需要有某种指标来衡量预测值$z$跟真实值$y$之间的差距。对于回归问题，最常采用的衡量方法是使用均方误差作为评价模型好坏的指标，具体定义如下：</p><script type="math/tex; mode=display">Loss = (y - z)^2</script><p>上式中的$Loss$（简记为: $L$）通常也被称作损失函数，它是衡量模型好坏的指标。在回归问题中，均方误差是一种比较常见的形式，分类问题中通常会采用交叉熵作为损失函数。</p><p>因为计算损失函数时需要把每个样本的损失函数值都考虑到，所以我们需要对单个样本的损失函数进行求和，并除以样本总数$N$。</p><script type="math/tex; mode=display">Loss= \frac{1}{N}\sum_{i=1}^N{(y_i - z_i)^2}</script><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>上述计算过程描述了如何构建神经网络，通过神经网络完成预测值和损失函数的计算。接下来介绍如何求解参数$w$和$b$的数值，这个过程也称为模型训练过程。训练过程是深度学习模型的关键要素之一，其目标是让定义的损失函数$Loss$尽可能的小，也就是说找到一个参数解$w$和$b$，使得损失函数取得极小值。</p><p>总代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Network</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, num_of_weights</span>):</span><br>        <span class="hljs-comment"># 随机产生w的初始值</span><br>        <span class="hljs-comment"># 为了保持程序每次运行结果的一致性，此处设置固定的随机数种子</span><br>        <span class="hljs-comment">#np.random.seed(0)</span><br>        self.w = np.random.randn(num_of_weights, <span class="hljs-number">1</span>)<br>        self.b = <span class="hljs-number">0.</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        z = np.dot(x, self.w) + self.b<br>        <span class="hljs-keyword">return</span> z<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loss</span>(<span class="hljs-params">self, z, y</span>):</span><br>        error = z - y<br>        num_samples = error.shape[<span class="hljs-number">0</span>]<br>        cost = error * error<br>        cost = np.<span class="hljs-built_in">sum</span>(cost) / num_samples<br>        <span class="hljs-keyword">return</span> cost<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gradient</span>(<span class="hljs-params">self, x, y</span>):</span><br>        z = self.forward(x)<br>        N = x.shape[<span class="hljs-number">0</span>]<br>        gradient_w = <span class="hljs-number">1.</span> / N * np.<span class="hljs-built_in">sum</span>((z-y) * x, axis=<span class="hljs-number">0</span>)<br>        gradient_w = gradient_w[:, np.newaxis]<br>        gradient_b = <span class="hljs-number">1.</span> / N * np.<span class="hljs-built_in">sum</span>(z-y)<br>        <span class="hljs-keyword">return</span> gradient_w, gradient_b<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, gradient_w, gradient_b, eta = <span class="hljs-number">0.01</span></span>):</span><br>        self.w = self.w - eta * gradient_w<br>        self.b = self.b - eta * gradient_b<br>            <br>                <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">self, training_data, num_epochs, batch_size=<span class="hljs-number">10</span>, eta=<span class="hljs-number">0.01</span></span>):</span><br>        n = <span class="hljs-built_in">len</span>(training_data)<br>        losses = []<br>        <span class="hljs-keyword">for</span> epoch_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>            <span class="hljs-comment"># 在每轮迭代开始之前，将训练数据的顺序随机打乱</span><br>            <span class="hljs-comment"># 然后再按每次取batch_size条数据的方式取出</span><br>            np.random.shuffle(training_data)<br>            <span class="hljs-comment"># 将训练数据进行拆分，每个mini_batch包含batch_size条的数据</span><br>            mini_batches = [training_data[k:k+batch_size] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n, batch_size)]<br>            <span class="hljs-keyword">for</span> iter_id, mini_batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(mini_batches):<br>                <span class="hljs-comment">#print(self.w.shape)</span><br>                <span class="hljs-comment">#print(self.b)</span><br>                x = mini_batch[:, :-<span class="hljs-number">1</span>]<br>                y = mini_batch[:, -<span class="hljs-number">1</span>:]<br>                a = self.forward(x)<br>                loss = self.loss(a, y)<br>                gradient_w, gradient_b = self.gradient(x, y)<br>                self.update(gradient_w, gradient_b, eta)<br>                losses.append(loss)<br>                print(<span class="hljs-string">&#x27;Epoch &#123;:3d&#125; / iter &#123;:3d&#125;, loss = &#123;:.4f&#125;&#x27;</span>.<br>                                 <span class="hljs-built_in">format</span>(epoch_id, iter_id, loss))<br>        <br>        <span class="hljs-keyword">return</span> losses<br><br><span class="hljs-comment"># 获取数据</span><br>train_data, test_data = load_data()<br><br><span class="hljs-comment"># 创建网络</span><br>net = Network(<span class="hljs-number">13</span>)<br><span class="hljs-comment"># 启动训练</span><br>losses = net.train(train_data, num_epochs=<span class="hljs-number">50</span>, batch_size=<span class="hljs-number">100</span>, eta=<span class="hljs-number">0.1</span>)<br><br><span class="hljs-comment"># 画出损失函数的变化趋势</span><br>plot_x = np.arange(<span class="hljs-built_in">len</span>(losses))<br>plot_y = np.array(losses)<br>plt.plot(plot_x, plot_y)<br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Paddle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paddle AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习与深度学习综述</title>
    <link href="/2021/01/27/paddle-1-1/"/>
    <url>/2021/01/27/paddle-1-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="机器学习与深度学习综述"><a href="#机器学习与深度学习综述" class="headerlink" title="机器学习与深度学习综述"></a>机器学习与深度学习综述</h1><h1 id="人工智能-gt-机器学习-gt-深度学习"><a href="#人工智能-gt-机器学习-gt-深度学习" class="headerlink" title="人工智能&gt;机器学习&gt;深度学习"></a>人工智能&gt;机器学习&gt;深度学习</h1><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="机器学习的实现"><a href="#机器学习的实现" class="headerlink" title="机器学习的实现"></a>机器学习的实现</h2><p>机器学习的实现可以分为两步：训练和预测：</p><ul><li><p>训练：从一定数量的样本（已知模型输入X 和模型输出Y）中，学习输出Y与输入X 的关系（可以想象成是某种表达式）。</p></li><li><p>预测：基于训练得到的Y与X之间的关系，如出现新的输入X，计算出输出Y。通常情况下，如果通过模型计算的输出和真实场景的输出一致，则说明模型是有效的。</p></li></ul><h2 id="机器学习的方法论"><a href="#机器学习的方法论" class="headerlink" title="机器学习的方法论"></a>机器学习的方法论</h2><ul><li><strong>模型有效的基本条件是能够拟合已知的样本</strong></li><li>以H 为模型的假设，它是一个关于参数W 和输入X的函数，用H(W,X) 表示。模型的优化目标是H(W,X) 的输出与真实输出Y 尽量一致，两者的相差程度即是模型效果的评价函数（相差越小越好）。那么，确定参数的过程就是在已知的样本上，不断减小该评价函数（H(W,X)和Y相差）的过程，直到学习到一个参数W，使得评价函数的取值最小。这个 <strong>衡量模型预测值和真实值差距的评价函数也被称为损失函数（损失 Loss）</strong>。</li><li><strong>模型假设、评价函数（损失 / 优化目标）和优化算法是构成模型的三个部分</strong>。</li><li>机器执行学习的框架体现了其<strong>学习的本质是 “参数估计”</strong>（Learning is parameter estimation）。</li></ul><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>相比传统的机器学习算法，深度学习做出了哪些改进呢？其实<strong>两者在理论结构上是一致的，即：模型假设、评价函数和优化算法，其根本差别在于假设的复杂度</strong> </p><h2 id="神经网络的基本概念"><a href="#神经网络的基本概念" class="headerlink" title="神经网络的基本概念"></a>神经网络的基本概念</h2><p>人工神经网络包括多个神经网络层，如卷积层、全连接层、LSTM 等，每一层又包括很多神经元，超过三层的非线性神经网络都可以被称为深度神经网络。通俗的讲，<strong>深度学习的模型可以视为是输入到输出的映射函数</strong>，如图像到高级语义（美女）的映射，<strong>足够深的神经网络理论上可以拟合任何复杂的函数</strong>。因此神经网络非常适合学习样本数据的内在规律和表示层次，对文字、图像和语音任务有很好的适用性。</p><p>神经网络的结构：</p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/af79017f3e1143fab258386460c324c4adf7ab0a51364fa98474d04798721752" alt=""></p><ul><li>神经元：神经网络中每个节点称为神经元，由两部分组成：<ul><li>加权和：将所有输入加权求和。</li><li>非线性变换（激活函数）：加权和的结果经过一个非线性函数变换，让神经元计算具备非线性的能力。</li></ul></li><li>多层连接：大量节点按照不同的层次排布，形成多层的结构连接起来，即称为神经网络。</li><li>前向计算：从输入计算输出的过程，顺序从网络前至后。</li><li>计算图：以图形化的方式展现神经网络的计算逻辑又称为计算图。我们也可以将神经网络的计算图以公式的方式表达，如下：</li></ul><script type="math/tex; mode=display">Y=f3(f2(f1(w1⋅x1+w2⋅x2+w3⋅x3+b)+…)…)…)Y =f_3 ( f_2 ( f_1 ( w_1\cdot x_1+w_2\cdot x_2+w_3\cdot x_3+b ) + … ) … ) … )*Y*=*f*3(*f*2(*f*1(*w*1⋅*x*1+*w*2⋅*x*2+*w*3⋅*x*3+*b*)+…)…)…)</script><p>神经网络并没有那么神秘，它的本质是一个含有很多参数的 “大公式”。</p>]]></content>
    
    
    <categories>
      
      <category>Paddle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paddle AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>paddle深度学习与图像处理</title>
    <link href="/2021/01/22/paddle-1/"/>
    <url>/2021/01/22/paddle-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深度学习与图像处理"><a href="#深度学习与图像处理" class="headerlink" title="深度学习与图像处理"></a>深度学习与图像处理</h1><h2 id="什么是深度学习？"><a href="#什么是深度学习？" class="headerlink" title="什么是深度学习？"></a>什么是深度学习？</h2><p>深度学习是一种机器学习模型，“建立模仿人大脑的模型”，就是使用神经网络这种函数解决机器学习问题，因为网路的层数多所以“深度”。</p><h2 id="如何使用深度学习解决图像识别？"><a href="#如何使用深度学习解决图像识别？" class="headerlink" title="如何使用深度学习解决图像识别？"></a>如何使用深度学习解决图像识别？</h2><ul><li>使用机器学习（深度学习）的目的： 寻找一个合适的函数</li></ul><h2 id="深度学习三部曲"><a href="#深度学习三部曲" class="headerlink" title="深度学习三部曲"></a>深度学习三部曲</h2><ul><li><p><strong>建立模型</strong>：</p><p>1.选择什么样的网络结构</p><p>2.选择多少层数，每层选择多少神经元</p></li><li><p><strong>损失函数</strong>：</p><p>1.选择常用损失函数：平方误差、交叉熵······</p></li><li><p><strong>参数学习</strong>：</p><p>1.梯度下降</p><p>2.反向传播算法</p></li></ul><h2 id="实践：手势识别"><a href="#实践：手势识别" class="headerlink" title="实践：手势识别"></a>实践：手势识别</h2><p>使用PaddlePaddle和深度神经网络（DNN）来完成手势识别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-comment"># In[ ]:</span><br><br><br><span class="hljs-comment"># 查看当前挂载的数据集目录, 该目录下的变更重启环境后会自动还原</span><br><span class="hljs-comment"># View dataset directory. This directory will be recovered automatically after resetting environment. </span><br>get_ipython().system(<span class="hljs-string">&#x27;ls /home/aistudio/data&#x27;</span>)<br><br><br><span class="hljs-comment"># In[ ]:</span><br><br><br><span class="hljs-comment"># 查看工作区文件, 该目录下的变更将会持久保存. 请及时清理不必要的文件, 避免加载过慢.</span><br><span class="hljs-comment"># View personal work directory. All changes under this directory will be kept even after reset. Please clean unnecessary files in time to speed up environment loading.</span><br>get_ipython().system(<span class="hljs-string">&#x27;ls /home/aistudio/work&#x27;</span>)<br><br><br><span class="hljs-comment"># In[ ]:</span><br><br><br>get_ipython().system(<span class="hljs-string">&#x27;cd /home/aistudio/data/data23668 &amp;&amp; unzip -qo Dataset.zip&#x27;</span>)<br>get_ipython().system(<span class="hljs-string">&#x27;cd /home/aistudio/data/data23668/Dataset &amp;&amp; rm -f */.DS_Store # 删除无关文件 &#x27;</span>)<br><br><br><span class="hljs-comment"># In[ ]:</span><br><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> paddle<br><span class="hljs-keyword">import</span> paddle.fluid <span class="hljs-keyword">as</span> fluid<br><span class="hljs-keyword">import</span> paddle.fluid.layers <span class="hljs-keyword">as</span> layers<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> cpu_count<br><span class="hljs-keyword">from</span> paddle.fluid.dygraph <span class="hljs-keyword">import</span> Pool2D,Conv2D<br><span class="hljs-keyword">from</span> paddle.fluid.dygraph <span class="hljs-keyword">import</span> Linear<br><br><br><span class="hljs-comment"># In[ ]:</span><br><br><br><span class="hljs-comment"># 生成图像列表</span><br>data_path = <span class="hljs-string">&#x27;/home/aistudio/data/data23668/Dataset&#x27;</span><br>character_folders = os.listdir(data_path)<br><span class="hljs-comment"># print(character_folders)</span><br><span class="hljs-keyword">if</span>(os.path.exists(<span class="hljs-string">&#x27;./train_data.list&#x27;</span>)):<br>    os.remove(<span class="hljs-string">&#x27;./train_data.list&#x27;</span>)<br><span class="hljs-keyword">if</span>(os.path.exists(<span class="hljs-string">&#x27;./test_data.list&#x27;</span>)):<br>    os.remove(<span class="hljs-string">&#x27;./test_data.list&#x27;</span>)<br>    <br><span class="hljs-keyword">for</span> character_folder <span class="hljs-keyword">in</span> character_folders:<br>    <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./train_data.list&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f_train:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./test_data.list&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f_test:<br>            <span class="hljs-keyword">if</span> character_folder == <span class="hljs-string">&#x27;.DS_Store&#x27;</span>:<br>                <span class="hljs-keyword">continue</span><br>            character_imgs = os.listdir(os.path.join(data_path,character_folder))<br>            count = <span class="hljs-number">0</span> <br>            <span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> character_imgs:<br>                <span class="hljs-keyword">if</span> img ==<span class="hljs-string">&#x27;.DS_Store&#x27;</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> count%<span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                    f_test.write(os.path.join(data_path,character_folder,img) + <span class="hljs-string">&#x27;\t&#x27;</span> + character_folder + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    f_train.write(os.path.join(data_path,character_folder,img) + <span class="hljs-string">&#x27;\t&#x27;</span> + character_folder + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>                count +=<span class="hljs-number">1</span><br>print(<span class="hljs-string">&#x27;列表已生成&#x27;</span>)<br><br><br><span class="hljs-comment"># In[ ]:</span><br><br><br><span class="hljs-comment"># 定义训练集和测试集的reader</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_mapper</span>(<span class="hljs-params">sample</span>):</span><br>    img, label = sample<br>    img = Image.<span class="hljs-built_in">open</span>(img)<br>    img = img.resize((<span class="hljs-number">100</span>, <span class="hljs-number">100</span>), Image.ANTIALIAS)<br>    img = np.array(img).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    img = img.transpose((<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>    img = img/<span class="hljs-number">255.0</span><br>    <span class="hljs-keyword">return</span> img, label<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_reader</span>(<span class="hljs-params">data_list_path</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reader</span>():</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_list_path, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            lines = f.readlines()<br>            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>                img, label = line.split(<span class="hljs-string">&#x27;\t&#x27;</span>)<br>                <span class="hljs-keyword">yield</span> img, <span class="hljs-built_in">int</span>(label)<br>    <span class="hljs-keyword">return</span> paddle.reader.xmap_readers(data_mapper, reader, cpu_count(), <span class="hljs-number">512</span>)<br><br><br><span class="hljs-comment"># In[ ]:</span><br><br><br><span class="hljs-comment"># 用于训练的数据提供器</span><br>train_reader = paddle.batch(reader=paddle.reader.shuffle(reader=data_reader(<span class="hljs-string">&#x27;./train_data.list&#x27;</span>), buf_size=<span class="hljs-number">256</span>), batch_size=<span class="hljs-number">32</span>)<br><span class="hljs-comment"># 用于测试的数据提供器</span><br>test_reader = paddle.batch(reader=data_reader(<span class="hljs-string">&#x27;./test_data.list&#x27;</span>), batch_size=<span class="hljs-number">32</span>) <br><br><br><span class="hljs-comment"># In[ ]:</span><br><br><br><span class="hljs-comment"># 定义DNN网络</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDNN</span>(<span class="hljs-params">fluid.dygraph.Layer</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(MyDNN, self).__init__()<br>        self.hidden1 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden2 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden3 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden4 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden5 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden6 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden7 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden8 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden9 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden10 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden11 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden12 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden13 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden14 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden15 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden16 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden17 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden18 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden19 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        self.hidden20 = Linear(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,act=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>        <span class="hljs-comment">#输出层</span><br>        self.hidden21 = Linear(<span class="hljs-number">3</span>*<span class="hljs-number">100</span>*<span class="hljs-number">100</span>,<span class="hljs-number">10</span>,act=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):</span><br>        x = self.hidden1(<span class="hljs-built_in">input</span>)<br>        x = self.hidden2(x)<br>        x = self.hidden3(x)<br>        x = self.hidden4(x)<br>        x = self.hidden5(x)<br>        x = self.hidden6(x)<br>        x = self.hidden7(x)<br>        x = self.hidden8(x)<br>        x = self.hidden9(x)<br>        x = self.hidden10(x)<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        x = self.hidden11(x)</span><br><span class="hljs-string">        x = self.hidden12(x)</span><br><span class="hljs-string">        x = self.hidden13(x)</span><br><span class="hljs-string">        x = self.hidden14(x)</span><br><span class="hljs-string">        x = self.hidden15(x)</span><br><span class="hljs-string">        x = self.hidden16(x)</span><br><span class="hljs-string">        x = self.hidden17(x)</span><br><span class="hljs-string">        x = self.hidden18(x)</span><br><span class="hljs-string">        x = self.hidden19(x)</span><br><span class="hljs-string">        x = self.hidden20(x)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br><br>        x = fluid.layers.reshape(x, shape=[-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>*<span class="hljs-number">100</span>*<span class="hljs-number">100</span>])<br><br>        y = self.hidden21(x)<br><br>        <span class="hljs-keyword">return</span> y<br><br><br><span class="hljs-comment"># In[11]:</span><br><br><br><span class="hljs-comment">#用动态图进行训练</span><br><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    model=MyDNN() <span class="hljs-comment">#模型实例化</span><br>    model.train() <span class="hljs-comment">#训练模式</span><br>    opt=fluid.optimizer.SGDOptimizer(learning_rate=<span class="hljs-number">0.001</span>, parameter_list=model.parameters())<span class="hljs-comment">#优化器选用SGD随机梯度下降，学习率为0.001.</span><br><br>    epochs_num=<span class="hljs-number">1000</span> <span class="hljs-comment">#迭代次数</span><br>     <br>    <span class="hljs-keyword">for</span> pass_num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs_num):<br>        <br>        <span class="hljs-keyword">for</span> batch_id,data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_reader()):<br>            <br>            images=np.array([x[<span class="hljs-number">0</span>].reshape(<span class="hljs-number">3</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data],np.float32)<br>            <br>            labels = np.array([x[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data]).astype(<span class="hljs-string">&#x27;int64&#x27;</span>)<br>            labels = labels[:, np.newaxis]<br>            <span class="hljs-comment"># print(images.shape)</span><br>            image=fluid.dygraph.to_variable(images)<br>            label=fluid.dygraph.to_variable(labels)<br>            predict=model(image)<br>            <br>            loss=fluid.layers.cross_entropy(predict,label)<br>            avg_loss=fluid.layers.mean(loss)<span class="hljs-comment">#获取loss值</span><br>            <br>            acc=fluid.layers.accuracy(predict,label)<span class="hljs-comment">#计算精度</span><br>            <br>            <span class="hljs-keyword">if</span> batch_id!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> batch_id%<span class="hljs-number">50</span>==<span class="hljs-number">0</span>:<br>                print(<span class="hljs-string">&quot;train_pass:&#123;&#125;,batch_id:&#123;&#125;,train_loss:&#123;&#125;,train_acc:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(pass_num,batch_id,avg_loss.numpy(),acc.numpy()))<br>            <br>            avg_loss.backward()<br>            opt.minimize(avg_loss)<br>            model.clear_gradients()<br>            <br>    fluid.save_dygraph(model.state_dict(),<span class="hljs-string">&#x27;MyDNN&#x27;</span>)<span class="hljs-comment">#保存模型</span><br><br><br><span class="hljs-comment"># In[14]:</span><br><br><br><span class="hljs-comment">#模型校验</span><br><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    accs = []<br>    model_dict, _ = fluid.load_dygraph(<span class="hljs-string">&#x27;MyDNN&#x27;</span>)<br>    model = MyDNN()<br>    model.load_dict(model_dict) <span class="hljs-comment">#加载模型参数</span><br>    model.<span class="hljs-built_in">eval</span>() <span class="hljs-comment">#训练模式</span><br>    <span class="hljs-keyword">for</span> batch_id,data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_reader()):<span class="hljs-comment">#测试集</span><br>        images=np.array([x[<span class="hljs-number">0</span>].reshape(<span class="hljs-number">3</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data],np.float32)<br>        labels = np.array([x[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data]).astype(<span class="hljs-string">&#x27;int64&#x27;</span>)<br>        labels = labels[:, np.newaxis]<br><br>        image=fluid.dygraph.to_variable(images)<br>        label=fluid.dygraph.to_variable(labels)<br>        <br>        predict=model(image)       <br>        acc=fluid.layers.accuracy(predict,label)<br>        accs.append(acc.numpy()[<span class="hljs-number">0</span>])<br>        avg_acc = np.mean(accs)<br>    print(avg_acc)<br><br><br><span class="hljs-comment"># In[17]:</span><br><br><br><span class="hljs-comment">#读取预测图像，进行预测</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_image</span>(<span class="hljs-params">path</span>):</span><br>    img = Image.<span class="hljs-built_in">open</span>(path)<br>    img = img.resize((<span class="hljs-number">100</span>, <span class="hljs-number">100</span>), Image.ANTIALIAS)<br>    img = np.array(img).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    img = img.transpose((<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>    img = img/<span class="hljs-number">255.0</span><br>    print(img.shape)<br>    <span class="hljs-keyword">return</span> img<br><br><span class="hljs-comment">#构建预测动态图过程</span><br><span class="hljs-keyword">with</span> fluid.dygraph.guard():<br>    infer_path = <span class="hljs-string">&#x27;./data/data23668/Dataset/6/IMG_4376.JPG&#x27;</span><br>    model=MyDNN()<span class="hljs-comment">#模型实例化</span><br>    model_dict,_=fluid.load_dygraph(<span class="hljs-string">&#x27;MyDNN&#x27;</span>)<br>    model.load_dict(model_dict)<span class="hljs-comment">#加载模型参数</span><br>    model.<span class="hljs-built_in">eval</span>()<span class="hljs-comment">#评估模式</span><br>    infer_img = load_image(infer_path)<br>    infer_img=np.array(infer_img).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    infer_img=infer_img[np.newaxis,:, : ,:]<br>    infer_img = fluid.dygraph.to_variable(infer_img)<br>    result=model(infer_img)<br>    display(Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data23668/Dataset/6/IMG_4376.JPG&#x27;</span>))<br>    print(np.argmax(result.numpy()))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习, 图像处理, CV, paddle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask 静态文件及渲染模板</title>
    <link href="/2021/01/20/flask-3/"/>
    <url>/2021/01/20/flask-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Flask-静态文件及渲染模板"><a href="#Flask-静态文件及渲染模板" class="headerlink" title="Flask 静态文件及渲染模板"></a>Flask 静态文件及渲染模板</h1><h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>动态的 web 应用同样需要静态文件。<code>CSS</code> 和 <code>JavaScript</code> 文件通常来源于此。理想情况下，你的 web 服务器已经配置好为它们服务，然而在开发过程中 Flask 就能够做到。只要在你的包中或模块旁边创建一个名为 <code>static</code> 的文件夹，在应用中使用 <code>/static</code> 即可访问。</p><p>给静态文件生成 URL ，使用特殊的 <code>static</code> 端点名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">url_for(<span class="hljs-string">&#x27;static&#x27;</span>, filename=<span class="hljs-string">&#x27;style.css&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这个文件是应该存储在文件系统上的 <code>static/style.css</code> 。</p><h2 id="渲染模板"><a href="#渲染模板" class="headerlink" title="渲染模板"></a>渲染模板</h2><p>可以使用方法 <code>render_template()</code> 来渲染模板。所有你需要做的就是提供模板的名称以及你想要作为关键字参数传入模板的变量。</p><p>渲染模板的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/hello/&#x27;</span></span>)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/hello/&lt;name&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>(<span class="hljs-params">name=<span class="hljs-literal">None</span></span>):</span>   <span class="hljs-comment"># 默认 name 为 None</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;hello.html&#x27;</span>, name=name)   <span class="hljs-comment"># 将 name 参数传递到模板变量中</span><br></code></pre></td></tr></table></figure><p>Flask 将会在 <code>templates</code> 文件夹中寻找模板。</p><p>对于模板，你可以使用 Jinja2 模板的全部能力。详细信息查看官方的 <a href="http://jinja.pocoo.org/docs/2.10/templates/">Jinja2 Template Documentation</a> 。</p><p>自动转义默认是开启的，因此如 <code>name</code> 包含 HTML，它将会自动转义。如果你信任一个变量，并且你知道它是安全的（例如一个模块把 wiki 标记转换到 HTML ），你可以用 <code>Markup</code> 类或 <code>|safe</code> 过滤器在模板中标记它是安全的。 在 Jinja 2 文档中，你会见到更多例子。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>静态文件放在 <code>static</code> 目录中，模板文件放在 <code>templates</code> 目录下。</p>]]></content>
    
    
    <categories>
      
      <category>Flask 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask, Web入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask 路由</title>
    <link href="/2021/01/20/flask-2/"/>
    <url>/2021/01/20/flask-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Flask-路由"><a href="#Flask-路由" class="headerlink" title="Flask 路由"></a>Flask 路由</h1><h2 id="路由介绍"><a href="#路由介绍" class="headerlink" title="路由介绍"></a>路由介绍</h2><p><code>route</code> 装饰器是用于把一个函数绑定到一个 URL 上</p><p>例如上次的 <code>hello.py</code>文件可以修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><span class="hljs-comment"># 如果访问根目录 &#x27;/&#x27; ，返回 Index Page</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Index Page&#x27;</span><br><br><span class="hljs-comment"># 如果访问 &#x27;/hello&#x27; ，返回 Hello, World!</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/hello&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, World!&#x27;</span><br></code></pre></td></tr></table></figure><p>这样就实现了通过访问不同的 URL 地址从而响应不同的页面。不仅如此！你可以动态地构造 URL 的特定部分，也可以在一个函数上绑定多个不同的规则。</p><h2 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h2><p>为了给 URL 增加变量的部分，你需要把一些特定的字段标记成 <code>&lt;variable_name&gt;</code>。这些特定的字段将作为参数传入到你的函数中。当然也可以指定一个可选的转换器通过规则 <code>&lt;converter:variable_name&gt;</code>将变量值转换为特定的数据类型。</p><p>在<code>hello.py</code>中添加代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&lt;username&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_user_profile</span>(<span class="hljs-params">username</span>):</span><br>    <span class="hljs-comment"># 显示用户名</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;User &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(username)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/post/&lt;int:post_id&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_post</span>(<span class="hljs-params">post_id</span>):</span><br>    <span class="hljs-comment"># 显示提交整型的用户&quot;id&quot;的结果，注意&quot;int&quot;是将输入的字符串形式转换为整型数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Post &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(post_id)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/path/&lt;path:subpath&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_subpath</span>(<span class="hljs-params">subpath</span>):</span><br>    <span class="hljs-comment"># 显示 /path/ 之后的路径名</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Subpath &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(subpath)<br></code></pre></td></tr></table></figure><p>转换器的主要类型如下：</p><div class="table-container"><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>string</td><td>默认的数据类型，接受没有任何斜杠 “/” 的字符串</td></tr><tr><td>int</td><td>接受整型</td></tr><tr><td>float</td><td>接受浮点类型</td></tr><tr><td>path</td><td>和 string 类似，但是接受斜杠 “/”</td></tr><tr><td>uuid</td><td>只接受 uuid 字符串</td></tr></tbody></table></div><h3 id="唯一-URLs-重定向行为"><a href="#唯一-URLs-重定向行为" class="headerlink" title="唯一 URLs / 重定向行为"></a>唯一 URLs / 重定向行为</h3><p>添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/projects/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">projects</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;The project page&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/about&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">about</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;The about page&#x27;</span><br></code></pre></td></tr></table></figure><p>第一种情况中：尾端有一个斜杠，当用户输入网址时忘了添加尾部的斜杠，系统回自动重定向到带了尾部斜杠的地址</p><p>第二种情况中：尾端不带斜杠，当用户输入网址时多添加了尾部的斜杠，系统回报错<code>Not Found</code></p><p>所以，在代码的 URL 设置时斜线只可多写不可少写，另外，URL设置不在尾端加斜杠 <code>/</code> 会使URL保持唯一，有助于避免搜索引擎索引同一个页面两次。</p><h3 id="构建URL"><a href="#构建URL" class="headerlink" title="构建URL"></a>构建URL</h3><p>去构建一个 URL 来匹配一个特定的函数可以使用 <code>url_for()</code> 方法。它接受函数名作为第一个参数，以及一些关键字参数，每一个关键字参数对应于 URL 规则的变量部分。未知变量部分被插入到 URL 中作为查询参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, url_for<br></code></pre></td></tr></table></figure><h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h2><p>HTTP (也就是 Web 应用协议) 有不同的方法来访问 URLs 。默认情况下，路由只会响应 GET 请求，但是能够通过给 <code>route()</code> 装饰器提供 <code>methods</code> 参数来改变。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        do_the_login()   <span class="hljs-comment"># 如果是 POST 方法就执行登录操作</span><br>    <span class="hljs-keyword">else</span>:<br>        show_the_login_form()   <span class="hljs-comment"># 如果是 GET 方法就展示登录表单</span><br></code></pre></td></tr></table></figure><p>也许你并不清楚 HTTP 方法是什么？别担心，这里有一个 HTTP 方法的快速入门以及为什么它们重要：</p><p><code>HTTP</code> 方法（通常也称为 “谓词”）告诉服务器客户端想要对请求的页面做什么。</p><p>下面这些方法是比较常见的：</p><ul><li>GET：浏览器通知服务器只获取页面上的信息并且发送回来。这可能是最常用的方法。</li><li>HEAD：浏览器告诉服务器获取信息，但是只对头信息感兴趣，不需要整个页面的内容。应用应该处理起来像接收到一个 GET 请求但是不传递实际内容。在 Flask 中你完全不需要处理它，底层的 Werkzeug 库会为你处理的。</li><li>POST：浏览器通知服务器它要在 URL 上提交一些信息，服务器必须保证数据被存储且只存储一次。这是 HTML 表单通常发送数据到服务器的方法。</li><li>PUT：同 POST 类似，但是服务器可能触发了多次存储过程，多次覆盖掉旧值。现在你就会问这有什么用，有许多理由需要如此去做。考虑下在传输过程中连接丢失：在这种情况下浏览器和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。该过程操作 POST 方法是不可能实现的，因为它只会被触发一次。</li><li>DELETE：移除给定位置的信息。</li><li>OPTIONS：给客户端提供一个快速的途径来指出这个 URL 支持哪些 HTTP 方法。从 Flask 0.6 开始，自动实现了该功能。</li></ul><p>现在在 HTML4 和 XHTML1 中，表单只能以 GET 和 POST 方法来提交到服务器。在 JavaScript 和以后的 HTML 标准中也能使用其它的方法。同时，HTTP 最近变得十分流行，浏览器不再是唯一使用 HTTP 的客户端。比如许多版本控制系统使用 HTTP。</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>练习题1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 请开发一个小应用</span><br><span class="hljs-comment"># URL 地址输入 http://127.0.0.1:5000/xxx（其中 xxx 表示你的名字）</span><br><span class="hljs-comment"># 访问页面会显示 xxx。</span><br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&lt;username&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span>(<span class="hljs-params">username</span>):</span><br>    <span class="hljs-keyword">return</span> username<br></code></pre></td></tr></table></figure><p>练习题2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 请完成一个应用</span><br><span class="hljs-comment"># 当 URL 是 http://127.0.0.1:5000/sum/a/b 时</span><br><span class="hljs-comment"># 其中 a 和 b 都是数字，服务器返回它们的和。</span><br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/sum/&lt;int:a&gt;/&lt;int:b&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sum</span>(<span class="hljs-params">a,b</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a,b,a+b)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Flask 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask, Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask介绍及安装</title>
    <link href="/2021/01/20/flask-1/"/>
    <url>/2021/01/20/flask-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Flask介绍及安装"><a href="#Flask介绍及安装" class="headerlink" title="Flask介绍及安装"></a>Flask介绍及安装</h1><h2 id="Flask-简介"><a href="#Flask-简介" class="headerlink" title="Flask 简介"></a>Flask 简介</h2><p>Flask 是一个轻量级的 Web 应用框架，使用 Python 编写。基于 <a href="http://werkzeug.pocoo.org/">WerkzeugWSGI</a> 工具箱和 <a href="http://jinja.pocoo.org/">Jinja2</a> 模板引擎。使用 BSD 授权。Flask 也被称为 microframework ，因为它使用简单的核心，用 extension 增加其它功能。Flask 没有默认使用的数据库、窗体验证工具。然而，Flask 保留了扩增的弹性，可以用 Flask-extension 加入这些功能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术。</p><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><p>virtualenv 能够允许多个不同版本的 Python 安装，每一个服务于各自的项目。它实际上并没有安装独立的 Python 副本，只是提供了一种方式使得环境保持独立。</p><h3 id="安装-virtualenv"><a href="#安装-virtualenv" class="headerlink" title="安装 virtualenv"></a>安装 virtualenv</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 使用如下命令即可很容易地安装 virtualenv 库：<br>$ sudo pip3 install virtualenv<br><br># 我们可以执行如下命令升级 pip 和 virtualenv 到最新版：<br>$ sudo pip3 install -U pip virtualenv<br><br># 执行如下命令可以查看 virtualenv 的版本：<br>$ pip3 <span class="hljs-keyword">freeze</span> | grep virtualenv<br><br></code></pre></td></tr></table></figure><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 执行命令创建虚拟环境</span><br>$ virtualenv -p python3 venv<br><br><span class="hljs-meta"># virtualenv 的命令中，-p 选项后面是选择解释器的版本为 python3 </span><br><span class="hljs-meta"># 最后的参数 venv 是虚拟环境的名字，执行此命令会创建一个虚拟环境的目录，目录名就是 venv 。</span><br></code></pre></td></tr></table></figure><h3 id="进入虚拟环境"><a href="#进入虚拟环境" class="headerlink" title="进入虚拟环境"></a>进入虚拟环境</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ source ~<span class="hljs-regexp">/XXX/</span>venv<span class="hljs-regexp">/bin/</span>activate<br><span class="hljs-comment"># 其中XXX为工作目录，venv为环境目录名</span><br></code></pre></td></tr></table></figure><h2 id="安装-Flask"><a href="#安装-Flask" class="headerlink" title="安装 Flask"></a>安装 Flask</h2><p>在虚拟环境中安装 Flask 框架的 1.0.2 版本，执行如下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ pip install <span class="hljs-attribute">flask</span>==1.0.2<br><br><span class="hljs-comment"># 其中双等号后面即为版本号，如果不写版本号，则默认安装适用于 Python3.5 的最新版本。</span><br></code></pre></td></tr></table></figure><h2 id="第一个最小的-Web-应用"><a href="#第一个最小的-Web-应用" class="headerlink" title="第一个最小的 Web 应用"></a>第一个最小的 Web 应用</h2><p>在VS Code 中新建hello.py，写入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, World!&#x27;</span><br></code></pre></td></tr></table></figure><p>执行应用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 第一种方法</span><br><span class="hljs-builtin-name">export</span> FLASK_APP = hello.py<br>flask run<br><br><span class="hljs-comment"># 第二种方法</span><br><span class="hljs-builtin-name">export</span> FLASK_APP = hello.py<br>python3 -m flask run<br><br></code></pre></td></tr></table></figure><p>调试模式</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 为了让所有的开发者特征可用（包括调试模式），</span><br><span class="hljs-comment"># 在运行服务器之前可以设置 FLASK_ENV 环境变量为 development：</span><br><br><span class="hljs-builtin-name">export</span> FLASK_ENV = development<br><span class="hljs-builtin-name">export</span> FLASK_DEBUG = 1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Flask 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask, Web入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux用户及文件权限管理</title>
    <link href="/2021/01/18/linux-2/"/>
    <url>/2021/01/18/linux-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="用户及文件权限管理"><a href="#用户及文件权限管理" class="headerlink" title="用户及文件权限管理"></a>用户及文件权限管理</h1><p>Linux 的<strong>用户管理</strong>和<strong>权限机制</strong>，不同用户不可以轻易地查看、修改彼此的文件</p><h1 id="一、Linux-用户管理"><a href="#一、Linux-用户管理" class="headerlink" title="一、Linux 用户管理"></a>一、Linux 用户管理</h1><h2 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h2><p>打开终端，输入命令</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vala">who am i<br><span class="hljs-meta"># 或者</span><br>who mom likes <br><br><span class="hljs-meta"># 注意：要查看当前登录用户的用户名，去掉空格直接使用 whoami 即可</span><br>whoami<br></code></pre></td></tr></table></figure><p><code>who</code>命令的其他常用参数</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>打印能打印的全部</td></tr><tr><td><code>-d</code></td><td>打印死掉的进程</td></tr><tr><td><code>-m</code></td><td>同 <code>am i</code>，<code>mom likes</code></td></tr><tr><td><code>-q</code></td><td>打印当前登录用户数及用户名</td></tr><tr><td><code>-u</code></td><td>打印当前登录用户登录信息</td></tr><tr><td><code>-r</code></td><td>打印运行等级</td></tr></tbody></table></div><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>在 Linux 系统里， <code>root</code> 账户拥有整个系统至高无上的权限，比如新建和添加用户。</p><p>一般我们登录系统时都是以普通账户的身份登录的，要创建用户需要 root 权限，这里就要用到 <code>sudo</code> 这个命令了。不过使用这个命令有两个大前提，一是你要知道当前登录用户的密码，二是当前用户必须在 <code>sudo</code> 用户组。</p><h3 id="su，su-与-sudo"><a href="#su，su-与-sudo" class="headerlink" title="su，su- 与 sudo"></a>su，su- 与 sudo</h3><p><strong>需要注意Linux环境下输入密码时不会显示的</strong></p><p><code>su</code> 可以切换到用户 user，执行时需要输入目标用户的密码，<code>sudo</code> 可以以特权级别运行 cmd 命令，需要当前用户属于 sudo 组，且需要输入当前用户的密码。<code>su -</code> 命令也是切换用户，但是同时用户的环境变量和工作目录也会跟着改变成目标用户所对应的。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 我们创建一个叫`boy`的用户</span><br>sudo <span class="hljs-keyword">adduser </span><span class="hljs-keyword">boy</span><br><span class="hljs-keyword"># </span>修改用户密码的命令<br>sudo passwd <span class="hljs-keyword">boy</span><br><span class="hljs-keyword"># </span>切换登录用户<br>su -l <span class="hljs-keyword">boy</span><br></code></pre></td></tr></table></figure><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>在 Linux 里面每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。</p><h3 id="查看属于的用户组"><a href="#查看属于的用户组" class="headerlink" title="查看属于的用户组"></a>查看属于的用户组</h3><h4 id="方法一：使用-groups-命令"><a href="#方法一：使用-groups-命令" class="headerlink" title="方法一：使用 groups 命令"></a>方法一：使用 groups 命令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 查看boy所属的用户组</span><br><span class="hljs-attribute">groups</span> boy<br></code></pre></td></tr></table></figure><h4 id="方法二：查看-etc-group-文件"><a href="#方法二：查看-etc-group-文件" class="headerlink" title="方法二：查看 /etc/group 文件"></a>方法二：查看 /etc/group 文件</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">cat /etc/<span class="hljs-keyword">group</span> <span class="hljs-title">| sort</span><br></code></pre></td></tr></table></figure><p>这里的<code>cat</code>命令用于读取指定文件的内容并打印到终端输出， <code>| sort</code> 表示将读取的文本进行一个字典排序再输出</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 使用 grep 命令过滤不想看到的内容（类似于关键词查找）</span><br>cat /etc/<span class="hljs-keyword">group</span> <span class="hljs-title">| grep</span> -E <span class="hljs-string">&quot;boy&quot;</span><br></code></pre></td></tr></table></figure><h3 id="将其他用户加入-sudo-用户组"><a href="#将其他用户加入-sudo-用户组" class="headerlink" title="将其他用户加入 sudo 用户组"></a>将其他用户加入 sudo 用户组</h3><p>默认情况下新创建的用户是不具有 root 权限的，也不在 sudo 用户组，可以让其加入 sudo 用户组从而获取 root 权限：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">su</span> -<span class="hljs-keyword">l</span> boy<br>sudo <span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><p>可能会提示 boy 不在 sudoers 文件中，意思就是 boy 不在 sudo 用户组中</p><p>使用 <code>usermod</code> 命令可以为用户添加用户组，同样使用该命令你必需有 root 权限，你可以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 切换回主用户pgj</span><br>su - pgj<br><br><span class="hljs-meta"># 开始设置 boy 用户为sudo用户组中</span><br>groups boy<br>sudo usermod -G sudo boy<br>groups boy<br><br><span class="hljs-meta"># 使用 sudo 获取 root 权限</span><br>su - boy<br>sudo ls /<br></code></pre></td></tr></table></figure><h3 id="删除用户和用户组"><a href="#删除用户和用户组" class="headerlink" title="删除用户和用户组"></a>删除用户和用户组</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 删除用户so easy</span><br>sudo deluser boy --remove-home<br><span class="hljs-meta"># 使用 --remove-home 参数在删除用户时候会一并将该用户的工作目录一并删除。如果不使用那么系统会自动在 /home 目录为该用户保留工作目录。</span><br><br><br><span class="hljs-meta"># 删除用户组可以使用 groupdel 命令，倘若该群组中仍包括某些用户，则必须先删除这些用户后，才能删除群组。</span><br></code></pre></td></tr></table></figure><h1 id="二、Linux-文件权限"><a href="#二、Linux-文件权限" class="headerlink" title="二、Linux 文件权限"></a>二、Linux 文件权限</h1><p>文件权限就是文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么样的操作。</p><h2 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限"></a>查看文件权限</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 使用 ls 命令查看文件权限，使用较长格式列出文件</span><br><span class="hljs-keyword">ls</span> -l<br></code></pre></td></tr></table></figure><p><code>ls</code>命令的其他常用的用法：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 显示除了 .（当前目录）和 ..（上一级目录）之外的所有文件，包括隐藏文件（Linux 下以 . 开头的文件为隐藏文件）。</span><br>ls -a<br><br><span class="hljs-meta"># 查看一个目录的完整属性，而不是显示目录里面的文件属性</span><br>ls -dl &lt;目录名&gt;<br><br><span class="hljs-meta"># 显示所有文件大小，并以普通人类能看懂的方式呈现</span><br>ls -asSh<br><span class="hljs-meta"># 其中小s为显示文件大小，大S为按文件大小排序，具体可以使用 `man ls`命令查询 </span><br></code></pre></td></tr></table></figure><h2 id="变更文件所有者"><a href="#变更文件所有者" class="headerlink" title="变更文件所有者"></a>变更文件所有者</h2><p>切换到 boy 用户，在/home/boy目录新建一个文件，命名为lover</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">su</span> - boy<br><span class="hljs-keyword">pwd</span><br>touch lover<br><span class="hljs-keyword">ls</span> -alh lover<br></code></pre></td></tr></table></figure><p>切换回到 pgj(主用户) 用户，使用以下命令变更文件所有者为 pgj。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 切换回 pgj 用户再执行一下操作</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">/home/boy</span><br><span class="hljs-keyword">ls</span> lover<br><span class="hljs-comment"># 最关键的一步：</span><br>sudo chown pgj lover<br></code></pre></td></tr></table></figure><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><p>文件的权限有两种表示方式：</p><h3 id="数字表示"><a href="#数字表示" class="headerlink" title="数字表示"></a>数字表示</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 修改lover文件的权限</span><br>chmod <span class="hljs-number">600</span> lover<br><span class="hljs-meta"># 其中600是某种权限对应的数字</span><br>ls -alh lover<br></code></pre></td></tr></table></figure><h3 id="加减赋值操作"><a href="#加减赋值操作" class="headerlink" title="加减赋值操作"></a>加减赋值操作</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 也可以使用一下命令修改权限</span><br><span class="hljs-keyword">chmod</span> go-rw lover<br></code></pre></td></tr></table></figure><p><code>g</code>、<code>o</code> 还有 <code>u</code> 分别表示 group（用户组）、others（其他用户） 和 user（用户），<code>+</code> 和 <code>-</code> 分别表示增加和去掉相应的权限。</p>]]></content>
    
    
    <categories>
      
      <category>Linux入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基本操作体验</title>
    <link href="/2021/01/18/linux-1/"/>
    <url>/2021/01/18/linux-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux基本操作体验"><a href="#Linux基本操作体验" class="headerlink" title="Linux基本操作体验"></a>Linux基本操作体验</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#创建一个名为`file`的文件，touch 是一个命令</span><br>touch file<br><br><span class="hljs-comment">#进入一个目录，cd是一个命令</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">/etc/</span><br><br><span class="hljs-comment">#查看当前所在目录</span><br><span class="hljs-keyword">pwd</span><br></code></pre></td></tr></table></figure><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>​    在<code>Xfce终端</code>中，可以使用<code>Tab</code>键来进行命令补全，<code>Ctrl + C</code> 可以强行终止当前程序</p><h2 id="其他一些快捷键"><a href="#其他一些快捷键" class="headerlink" title="其他一些快捷键"></a>其他一些快捷键</h2><div class="table-container"><table><thead><tr><th style="text-align:left">按键</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:left"><code>Ctrl + d</code></td><td>键盘输入结束或退出终端</td></tr><tr><td style="text-align:left"><code>Ctrl + s</code></td><td>暂停当前程序，暂停后按下任意键恢复运行</td></tr><tr><td style="text-align:left"><code>Ctrl + z</code></td><td>将当前程序放到后台运行，恢复到前台为命令<code>fg</code></td></tr><tr><td style="text-align:left"><code>Ctrl + a</code></td><td>将光标移至输入行头，相当于<code>Home</code>键</td></tr><tr><td style="text-align:left"><code>Ctrl + e</code></td><td>将光标移至输入行末，相当于<code>End</code>键</td></tr><tr><td style="text-align:left"><code>Ctrl + k</code></td><td>删除从光标所在位置到行末</td></tr><tr><td style="text-align:left"><code>Alt + Backspace</code></td><td>向前删除一个单词</td></tr><tr><td style="text-align:left"><code>Shift + PgUp</code></td><td>将终端显示向上滚动</td></tr><tr><td style="text-align:left"><code>Shift + PgDn</code></td><td>将终端显示向下滚动</td></tr></tbody></table></div><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>Shell 常用的通配符</p><div class="table-container"><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配 0 或多个字符</td></tr><tr><td><code>?</code></td><td>匹配任意一个字符</td></tr><tr><td><code>[list]</code></td><td>匹配 list 中的任意单一字符</td></tr><tr><td><code>[^list]</code></td><td>匹配 除 list 中的任意单一字符以外的字符</td></tr><tr><td><code>[c1-c2]</code></td><td>匹配 c1-c2 中的任意单一字符 如：<code>[0-9]</code> <code>[a-z]</code></td></tr><tr><td><code>&#123;string1,string2,...&#125;</code></td><td>匹配 string1 或 string2 (或更多) 其一字符串</td></tr><tr><td><code>&#123;c1..c2&#125;</code></td><td>匹配 c1-c2 中全部字符 如 {1..10}</td></tr></tbody></table></div><h1 id="学会在命令行中获取帮助"><a href="#学会在命令行中获取帮助" class="headerlink" title="学会在命令行中获取帮助"></a>学会在命令行中获取帮助</h1><h2 id="使用-man-命令"><a href="#使用-man-命令" class="headerlink" title="使用 man 命令"></a>使用 man 命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#可以使用如下方式获得某个命令的说明和使用的详细介绍</span><br><span class="hljs-built_in">man</span> &lt;command_name&gt;<br><span class="hljs-comment">#查看man命令本身的使用方式</span><br><span class="hljs-built_in">man</span> <span class="hljs-built_in">man</span><br></code></pre></td></tr></table></figure><h2 id="使用help参数"><a href="#使用help参数" class="headerlink" title="使用help参数"></a>使用help参数</h2><p>如果你知道某个命令的作用，只是想快速查看一些它的某个具体参数的作用，那么你可以使用 <code>--help</code> 参数，大部分命令都会带有这个参数，如：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-params">--help</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown简单使用教程</title>
    <link href="/2021/01/17/Markdown/"/>
    <url>/2021/01/17/Markdown/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Markdown简单使用教程"><a href="#Markdown简单使用教程" class="headerlink" title="Markdown简单使用教程"></a>Markdown简单使用教程</h1><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>标题有两种格式，这里是使用<code>#</code>格式。使用<code>#</code>号可以表示1-6级标题</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><span class="hljs-section">## 二级标题</span><br><span class="hljs-section">### 三级标题</span><br><span class="hljs-section">#### 四级标题</span><br><span class="hljs-section">##### 五级标题</span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure><h2 id="二、段落格式"><a href="#二、段落格式" class="headerlink" title="二、段落格式"></a>二、段落格式</h2><ol><li><p>段落换行</p><p>Markdown段落换行是使用两个以上空格加上回车<br>当然也可以直接在段落后面使用一个空格来表示新开段落</p></li></ol><ol><li><p>字体</p><p>Markdown可以使用一下几种字体<br><code>*斜体文字*</code>或者<code>—斜体文字—</code><br><code>**粗体文字**</code>或者<code>——粗体文字——</code><br><code>***粗斜体文字***</code>或者<code>———粗斜体文字———</code></p></li></ol><ol><li><p>分割线</p><p>你可以在一行中用三个以上的星号(<code>+</code>)、减号(<code>-</code>)、底线(<code>-</code>)来建立一个分割线，行内不能有其他东西。<br>也可以在星号或是减号中间插入空格。<br>下面每种写法都可以创建分割线：</p></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-strong"><span class="hljs-emphasis"></span></span><br><span class="hljs-strong"><span class="hljs-emphasis">*</span> <span class="hljs-emphasis">* *</span></span><br><span class="hljs-strong"></span><br><span class="hljs-strong">**</span><span class="hljs-strong">****</span><br><br><span class="hljs-bullet">-</span> - -<br><br>-------------<br></code></pre></td></tr></table></figure><ol><li><p>删除线</p><p>如果要在段落的文字上添加删除线，只需要在文字的两端加上两个波浪线 <code>~~</code>即可</p></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">#例如</span><br><br>~~Hello,girls~~<br></code></pre></td></tr></table></figure><ol><li><p>下划线</p><p>下划线课通过HTML的 <code>&lt;u&gt;</code>标签来实现：</p></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>带下划线文本<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol><li><p>脚注</p><p>Markdown脚注的格式如下：<br><code>[^要注明的文本]</code>例如</p></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[^PGJ] ： A handsome boy！<br></code></pre></td></tr></table></figure><h2 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h2><p>Markdown支持有序列表和无序列表</p><ol><li>无序列表使用星号（<code>*</code>）、加号（<code>+</code>）、减号（<code>-</code>）作为列表标记，这些标记后面要加一个空格再填写内容</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></td></tr></table></figure><ol><li>有序列表使用数字再加上点号（<code>.</code>）来表示，记得加上空格再填写内容</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure><ol><li>列表嵌套</li></ol><p>列表嵌套只需要再子列表的选项前面添加四个空格即可。</p><h2 id="四、区块"><a href="#四、区块" class="headerlink" title="四、区块"></a>四、区块</h2><p>区块就是显示区域左边会有一条线<br>Markdown 区块引用是在段落开头使用<code>&gt;</code>符号，然后后面紧跟一个空格符号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 区块引用</span><br><span class="hljs-quote">&gt; Hello</span><br><span class="hljs-quote">&gt; World!</span><br></code></pre></td></tr></table></figure><p>另外区块是可以嵌套的，一个<code>&gt;</code>符号是最外层，两个<code>&gt;</code>符号是第一层嵌套，以此类推</p><h2 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h2><ol><li>如果是段落上的一个函数或片段的代码可以用反引号（<code>）,这个反引号就是键盘</code>Esc`键下面的那个键</li></ol><ol><li>代码区块</li></ol><p>代码区块使用4个空格或者一个制表符（<code>Tab</code>键）</p><p>也可以用三个反引号（```）包裹一段代码，并指定一种语言（也可以不指定）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">​<span class="hljs-code">```javascript</span><br><span class="hljs-code">$(document).ready(function () &#123;</span><br><span class="hljs-code">    alert(&#x27;RUNOOB&#x27;);</span><br><span class="hljs-code">&#125;);</span><br></code></pre></td></tr></table></figure><h2 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h2><p>链接使用方法如下：</p><p><code>[连接名称](链接地址)</code><br>或者<br><code>&lt;链接地址&gt;</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是一个链接 [<span class="hljs-string">PGJ博客</span>](<span class="hljs-link">20to30.xyz</span>)<br><br> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">www.20to30.xyz</span>&gt;</span></span> <br></code></pre></td></tr></table></figure><h2 id="七、图片"><a href="#七、图片" class="headerlink" title="七、图片"></a>七、图片</h2><p>Markdown 图片语法格式如下：<br><code>![alt 属性文本](C:/Users/GJ/Documents/图片地址)</code><br><code>![alt 属性文本](C:/Users/GJ/Documents/图片地址 &quot;可选标题&quot;)</code></p><p>就是：开头一个感叹号<code>!</code>，接着一个方括号，里面放上图片的替代文字，<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的”titlt”属性的文字。</p><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行<br>语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|  表头   | 表头  |<br>|  ----  | ----  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br></code></pre></td></tr></table></figure><p>对齐方式<br><code>-:</code>设置内容和标题栏居右对齐<br><code>:-</code>设置内容和标题栏居左对齐<br><code>:-:</code>设置内容和标题栏居中对齐</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 左对齐 | 右对齐 | 居中对齐 |<br>| :-----| ----: | :----: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |<br></code></pre></td></tr></table></figure><h2 id="九、Markdown-高级技巧"><a href="#九、Markdown-高级技巧" class="headerlink" title="九、Markdown 高级技巧"></a>九、Markdown 高级技巧</h2><p>请查看教程 [<a href="https://www.runoob.com/markdown/md-advance.html">https://www.runoob.com/markdown/md-advance.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Markdown入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/13/hello-world/"/>
    <url>/2021/01/13/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
